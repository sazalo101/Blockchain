"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FederatedAttestationsWrapper = void 0;
const connect_1 = require("@celo/connect");
const typed_data_constructors_1 = require("@celo/utils/lib/typed-data-constructors");
const BaseWrapper_1 = require("./BaseWrapper");
class FederatedAttestationsWrapper extends BaseWrapper_1.BaseWrapper {
    constructor() {
        super(...arguments);
        /**
         * @notice Returns identifiers mapped to `account` by signers of `trustedIssuers`
         * @param account Address of the account
         * @param trustedIssuers Array of n issuers whose identifier mappings will be used
         * @return countsPerIssuer Array of number of identifiers returned per issuer
         * @return identifiers Array (length == sum([0])) of identifiers
         * @dev Adds identifier info to the arrays in order of provided trustedIssuers
         * @dev Expectation that only one attestation exists per (identifier, issuer, account)
         */
        this.lookupIdentifiers = (0, BaseWrapper_1.proxyCall)(this.contract.methods.lookupIdentifiers);
        /**
         * @notice Returns info about attestations for `identifier` produced by
         *    signers of `trustedIssuers`
         * @param identifier Hash of the identifier
         * @param trustedIssuers Array of n issuers whose attestations will be included
         * @return countsPerIssuer Array of number of attestations returned per issuer
         *          For m (== sum([0])) found attestations:
         * @return accounts Array of m accounts
         * @return signers Array of m signers
         * @return issuedOns Array of m issuedOns
         * @return publishedOns Array of m publishedOns
         * @dev Adds attestation info to the arrays in order of provided trustedIssuers
         * @dev Expectation that only one attestation exists per (identifier, issuer, account)
         */
        this.lookupAttestations = (0, BaseWrapper_1.proxyCall)(this.contract.methods.lookupAttestations);
        /**
         * @notice Validates the given attestation and signature
         * @param identifier Hash of the identifier to be attested
         * @param issuer Address of the attestation issuer
         * @param account Address of the account being mapped to the identifier
         * @param issuedOn Time at which the issuer issued the attestation in Unix time
         * @param signer Address of the signer of the attestation
         * @param v The recovery id of the incoming ECDSA signature
         * @param r Output value r of the ECDSA signature
         * @param s Output value s of the ECDSA signature
         * @dev Throws if attestation has been revoked
         * @dev Throws if signer is not an authorized AttestationSigner of the issuer
         */
        this.validateAttestationSig = (0, BaseWrapper_1.proxyCall)(this.contract.methods.validateAttestationSig);
        /**
         * @return keccak 256 of abi encoded parameters
         */
        this.getUniqueAttestationHash = (0, BaseWrapper_1.proxyCall)(this.contract.methods.getUniqueAttestationHash);
        /**
         * @notice Registers an attestation directly from the issuer
         * @param identifier Hash of the identifier to be attested
         * @param account Address of the account being mapped to the identifier
         * @param issuedOn Time at which the issuer issued the attestation in Unix time
         * @dev Attestation signer and issuer in storage is set to msg.sender
         * @dev Throws if an attestation with the same (identifier, issuer, account) already exists
         */
        this.registerAttestationAsIssuer = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.registerAttestationAsIssuer);
        /**
         * @notice Revokes an attestation
         * @param identifier Hash of the identifier to be revoked
         * @param issuer Address of the attestation issuer
         * @param account Address of the account mapped to the identifier
         * @dev Throws if sender is not the issuer, signer, or account
         */
        this.revokeAttestation = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.revokeAttestation);
        /**
         * @notice Revokes attestations [identifiers <-> accounts] from issuer
         * @param issuer Address of the issuer of all attestations to be revoked
         * @param identifiers Hash of the identifiers
         * @param accounts Addresses of the accounts mapped to the identifiers
         *   at the same indices
         * @dev Throws if the number of identifiers and accounts is not the same
         * @dev Throws if sender is not the issuer or currently registered signer of issuer
         * @dev Throws if an attestation is not found for identifiers[i] <-> accounts[i]
         */
        this.batchRevokeAttestations = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.batchRevokeAttestations);
    }
    /**
     * @notice Generates a valid signature and registers the attestation
     * @param identifier Hash of the identifier to be attested
     * @param issuer Address of the attestation issuer
     * @param account Address of the account being mapped to the identifier
     * @param issuedOn Time at which the issuer issued the attestation in Unix time
     * @param signer Address of the signer of the attestation
     * @dev Throws if an attestation with the same (identifier, issuer, account) already exists
     */
    registerAttestation(identifier, issuer, account, signer, issuedOn) {
        return __awaiter(this, void 0, void 0, function* () {
            const chainId = yield this.connection.chainId();
            const typedData = (0, typed_data_constructors_1.registerAttestation)(chainId, this.address, {
                identifier,
                issuer,
                account,
                signer,
                issuedOn,
            });
            const sig = yield this.connection.signTypedData(signer, typedData);
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.registerAttestation(identifier, issuer, account, signer, issuedOn, sig.v, sig.r, sig.s));
        });
    }
}
exports.FederatedAttestationsWrapper = FederatedAttestationsWrapper;
//# sourceMappingURL=FederatedAttestations.js.map