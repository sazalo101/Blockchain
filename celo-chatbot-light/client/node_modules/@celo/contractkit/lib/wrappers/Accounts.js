"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountsWrapper = void 0;
const signatureUtils_1 = require("@celo/base/lib/signatureUtils");
const connect_1 = require("@celo/connect");
const signatureUtils_2 = require("@celo/utils/lib/signatureUtils");
const solidity_1 = require("@celo/utils/lib/solidity");
const typed_data_constructors_1 = require("@celo/utils/lib/typed-data-constructors");
const getParsedSignatureOfAddress_1 = require("../utils/getParsedSignatureOfAddress");
const versions_1 = require("../versions");
const BaseWrapper_1 = require("../wrappers/BaseWrapper");
const BaseWrapper_2 = require("./BaseWrapper");
/**
 * Contract for handling deposits needed for voting.
 */
class AccountsWrapper extends BaseWrapper_2.BaseWrapper {
    constructor() {
        super(...arguments);
        this.RELEASE_4_VERSION = (0, versions_1.newContractVersion)(1, 1, 2, 0);
        /**
         * Creates an account.
         */
        this.createAccount = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.createAccount);
        /**
         * Returns the attestation signer for the specified account.
         * @param account The address of the account.
         * @return The address with which the account can vote.
         */
        this.getAttestationSigner = (0, BaseWrapper_1.proxyCall)(this.contract.methods.getAttestationSigner);
        /**
         * Returns if the account has authorized an attestation signer
         * @param account The address of the account.
         * @return If the account has authorized an attestation signer
         */
        this.hasAuthorizedAttestationSigner = (0, BaseWrapper_1.proxyCall)(this.contract.methods.hasAuthorizedAttestationSigner);
        /**
         * Returns the vote signer for the specified account.
         * @param account The address of the account.
         * @return The address with which the account can vote.
         */
        this.getVoteSigner = (0, BaseWrapper_1.proxyCall)(this.contract.methods.getVoteSigner);
        /**
         * Returns the validator signer for the specified account.
         * @param account The address of the account.
         * @return The address with which the account can register a validator or group.
         */
        this.getValidatorSigner = (0, BaseWrapper_1.proxyCall)(this.contract.methods.getValidatorSigner);
        /**
         * Returns the account address given the signer for voting
         * @param signer Address that is authorized to sign the tx as voter
         * @return The Account address
         */
        this.voteSignerToAccount = (0, BaseWrapper_1.proxyCall)(this.contract.methods.voteSignerToAccount);
        /**
         * Returns the account address given the signer for validating
         * @param signer Address that is authorized to sign the tx as validator
         * @return The Account address
         */
        this.validatorSignerToAccount = (0, BaseWrapper_1.proxyCall)(this.contract.methods.validatorSignerToAccount);
        /**
         * Returns the account associated with `signer`.
         * @param signer The address of the account or previously authorized signer.
         * @dev Fails if the `signer` is not an account or previously authorized signer.
         * @return The associated account.
         */
        this.signerToAccount = (0, BaseWrapper_1.proxyCall)(this.contract.methods.signerToAccount);
        /**
         * Check if an account already exists.
         * @param account The address of the account
         * @return Returns `true` if account exists. Returns `false` otherwise.
         */
        this.isAccount = (0, BaseWrapper_1.proxyCall)(this.contract.methods.isAccount);
        /**
         * Check if an address is a signer address
         * @param address The address of the account
         * @return Returns `true` if account exists. Returns `false` otherwise.
         */
        this.isSigner = (0, BaseWrapper_1.proxyCall)(this.contract.methods.isAuthorizedSigner);
        /**
         * Returns the set data encryption key for the account
         * @param account Account
         */
        this.getDataEncryptionKey = (0, BaseWrapper_1.proxyCall)(this.contract.methods.getDataEncryptionKey, undefined, (res) => (0, BaseWrapper_1.solidityBytesToString)(res));
        /**
         * Returns the set wallet address for the account
         * @param account Account
         */
        this.getWalletAddress = (0, BaseWrapper_1.proxyCall)(this.contract.methods.getWalletAddress);
        /**
         * Returns the metadataURL for the account
         * @param account Account
         */
        this.getMetadataURL = (0, BaseWrapper_1.proxyCall)(this.contract.methods.getMetadataURL);
        /**
         * Sets the data encryption of the account
         * @param encryptionKey The key to set
         */
        this.setAccountDataEncryptionKey = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.setAccountDataEncryptionKey);
        /**
         * Sets the name for the account
         * @param name The name to set
         */
        this.setName = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.setName);
        /**
         * Sets the metadataURL for the account
         * @param url The url to set
         */
        this.setMetadataURL = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.setMetadataURL);
        /**
         * Set a validator's payment delegation settings.
         * @param beneficiary The address that should receive a portion of validator
         * payments.
         * @param fraction The fraction of the validator's payment that should be
         * diverted to `beneficiary` every epoch, given as FixidityLib value. Must not
         * be greater than 1.
         * @dev Use `deletePaymentDelegation` to unset the payment delegation.
         */
        this.setPaymentDelegation = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.setPaymentDelegation);
        /**
         * Remove a validator's payment delegation by setting benficiary and
         * fraction to 0.
         */
        this.deletePaymentDelegation = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.deletePaymentDelegation);
        /**
         * Get a validator's payment delegation settings.
         * @param account Account of the validator.
         * @return Beneficiary address and fraction of payment delegated.
         */
        this.getPaymentDelegation = (0, BaseWrapper_1.proxyCall)(this.contract.methods.getPaymentDelegation);
    }
    getCurrentSigners(address) {
        return Promise.all([
            this.getVoteSigner(address),
            this.getValidatorSigner(address),
            this.getAttestationSigner(address),
        ]);
    }
    getAccountSummary(account) {
        return __awaiter(this, void 0, void 0, function* () {
            const ret = yield Promise.all([
                this.getName(account),
                this.getVoteSigner(account),
                this.getValidatorSigner(account),
                this.getAttestationSigner(account),
                this.getMetadataURL(account),
                this.getWalletAddress(account),
                this.getDataEncryptionKey(account),
            ]);
            return {
                address: account,
                name: ret[0],
                authorizedSigners: {
                    vote: ret[1],
                    validator: ret[2],
                    attestation: ret[3],
                },
                metadataURL: ret[4],
                wallet: ret[5],
                dataEncryptionKey: ret[6],
            };
        });
    }
    /**
     * Authorize an attestation signing key on behalf of this account to another address.
     * @param signer The address of the signing key to authorize.
     * @param proofOfSigningKeyPossession The account address signed by the signer address.
     * @return A CeloTransactionObject
     */
    authorizeAttestationSigner(signer, proofOfSigningKeyPossession) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.authorizeAttestationSigner(signer, proofOfSigningKeyPossession.v, proofOfSigningKeyPossession.r, proofOfSigningKeyPossession.s));
        });
    }
    /**
     * Authorizes an address to sign votes on behalf of the account.
     * @param signer The address of the vote signing key to authorize.
     * @param proofOfSigningKeyPossession The account address signed by the signer address.
     * @return A CeloTransactionObject
     */
    authorizeVoteSigner(signer, proofOfSigningKeyPossession) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.authorizeVoteSigner(signer, proofOfSigningKeyPossession.v, proofOfSigningKeyPossession.r, proofOfSigningKeyPossession.s));
        });
    }
    /**
     * Authorizes an address to sign consensus messages on behalf of the account.
     * @param signer The address of the signing key to authorize.
     * @param proofOfSigningKeyPossession The account address signed by the signer address.
     * @return A CeloTransactionObject
     */
    authorizeValidatorSigner(signer, proofOfSigningKeyPossession, validatorsWrapper) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = this.connection.defaultAccount || (yield this.connection.getAccounts())[0];
            if (yield validatorsWrapper.isValidator(account)) {
                const message = this.connection.web3.utils.soliditySha3({
                    type: 'address',
                    value: account,
                });
                const prefixedMsg = (0, signatureUtils_2.hashMessageWithPrefix)(message);
                const pubKey = (0, signatureUtils_2.signedMessageToPublicKey)(prefixedMsg, proofOfSigningKeyPossession.v, proofOfSigningKeyPossession.r, proofOfSigningKeyPossession.s);
                return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.authorizeValidatorSignerWithPublicKey(signer, proofOfSigningKeyPossession.v, proofOfSigningKeyPossession.r, proofOfSigningKeyPossession.s, (0, BaseWrapper_1.stringToSolidityBytes)(pubKey)));
            }
            else {
                return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.authorizeValidatorSigner(signer, proofOfSigningKeyPossession.v, proofOfSigningKeyPossession.r, proofOfSigningKeyPossession.s));
            }
        });
    }
    /**
     * Authorizes an address to sign consensus messages on behalf of the account. Also switch BLS key at the same time.
     * @param signer The address of the signing key to authorize.
     * @param proofOfSigningKeyPossession The account address signed by the signer address.
     * @param blsPublicKey The BLS public key that the validator is using for consensus, should pass proof
     *   of possession. 48 bytes.
     * @param blsPop The BLS public key proof-of-possession, which consists of a signature on the
     *   account address. 96 bytes.
     * @return A CeloTransactionObject
     */
    authorizeValidatorSignerAndBls(signer, proofOfSigningKeyPossession, blsPublicKey, blsPop) {
        return __awaiter(this, void 0, void 0, function* () {
            const account = this.connection.defaultAccount || (yield this.connection.getAccounts())[0];
            const message = this.connection.web3.utils.soliditySha3({
                type: 'address',
                value: account,
            });
            const prefixedMsg = (0, signatureUtils_2.hashMessageWithPrefix)(message);
            const pubKey = (0, signatureUtils_2.signedMessageToPublicKey)(prefixedMsg, proofOfSigningKeyPossession.v, proofOfSigningKeyPossession.r, proofOfSigningKeyPossession.s);
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.authorizeValidatorSignerWithKeys(signer, proofOfSigningKeyPossession.v, proofOfSigningKeyPossession.r, proofOfSigningKeyPossession.s, (0, BaseWrapper_1.stringToSolidityBytes)(pubKey), (0, BaseWrapper_1.stringToSolidityBytes)(blsPublicKey), (0, BaseWrapper_1.stringToSolidityBytes)(blsPop)));
        });
    }
    authorizeSigner(signer, role) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.onlyVersionOrGreater(this.RELEASE_4_VERSION);
            const [accounts, chainId] = yield Promise.all([
                this.connection.getAccounts(),
                this.connection.chainId(),
                // This IS the accounts contract wrapper no need to get it
            ]);
            const account = this.connection.defaultAccount || accounts[0];
            const hashedRole = this.keccak256(role);
            const typedData = (0, typed_data_constructors_1.authorizeSigner)({
                account,
                signer,
                chainId,
                role: hashedRole,
                accountsContractAddress: this.address,
            });
            const sig = yield this.connection.signTypedData(signer, typedData);
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.authorizeSignerWithSignature(signer, hashedRole, sig.v, sig.r, sig.s));
        });
    }
    startSignerAuthorization(signer, role) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.onlyVersionOrGreater(this.RELEASE_4_VERSION);
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.authorizeSigner(signer, this.keccak256(role)));
        });
    }
    completeSignerAuthorization(account, role) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.onlyVersionOrGreater(this.RELEASE_4_VERSION);
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.completeSignerAuthorization(account, this.keccak256(role)));
        });
    }
    /**
     * Removes the currently authorized attestation signer for the account
     * @returns A CeloTransactionObject
     */
    removeAttestationSigner() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.removeAttestationSigner());
        });
    }
    generateProofOfKeyPossession(account, signer) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getParsedSignatureOfAddress(account, signer, (0, signatureUtils_1.NativeSigner)(this.connection.web3.eth.sign, signer));
        });
    }
    generateProofOfKeyPossessionLocally(account, signer, privateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getParsedSignatureOfAddress(account, signer, (0, signatureUtils_2.LocalSigner)(privateKey));
        });
    }
    /**
     * Returns the set name for the account
     * @param account Account
     * @param blockNumber Height of result, defaults to tip.
     */
    getName(account, blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore: Expected 0-1 arguments, but got 2
            return this.contract.methods.getName(account).call({}, blockNumber);
        });
    }
    /**
     * Convenience Setter for the dataEncryptionKey and wallet address for an account
     * @param name A string to set as the name of the account
     * @param dataEncryptionKey secp256k1 public key for data encryption. Preferably compressed.
     * @param walletAddress The wallet address to set for the account
     * @param proofOfPossession Signature from the wallet address key over the sender's address
     */
    setAccount(name, dataEncryptionKey, walletAddress, proofOfPossession = null) {
        if (proofOfPossession) {
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.setAccount(name, 
            // @ts-ignore
            dataEncryptionKey, walletAddress, proofOfPossession.v, proofOfPossession.r, proofOfPossession.s));
        }
        else {
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.setAccount(name, 
            // @ts-ignore
            dataEncryptionKey, walletAddress, '0x0', '0x0', '0x0'));
        }
    }
    /**
     * Sets the wallet address for the account
     * @param address The address to set
     */
    setWalletAddress(walletAddress, proofOfPossession = null) {
        if (proofOfPossession) {
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.setWalletAddress(walletAddress, proofOfPossession.v, proofOfPossession.r, proofOfPossession.s));
        }
        else {
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.setWalletAddress(walletAddress, '0x0', '0x0', '0x0'));
        }
    }
    parseSignatureOfAddress(address, signer, signature) {
        const hash = (0, solidity_1.soliditySha3)({ type: 'address', value: address });
        return (0, signatureUtils_2.parseSignature)(hash, signature, signer);
    }
    getParsedSignatureOfAddress(address, signer, signerFn) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, getParsedSignatureOfAddress_1.getParsedSignatureOfAddress)(solidity_1.soliditySha3, signerFn.sign, address, signer);
        });
    }
    keccak256(value) {
        return this.connection.keccak256(value);
    }
}
exports.AccountsWrapper = AccountsWrapper;
//# sourceMappingURL=Accounts.js.map