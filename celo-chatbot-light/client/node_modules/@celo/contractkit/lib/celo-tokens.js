"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isStableTokenContract = exports.CeloTokens = exports.celoTokenInfos = exports.stableTokenInfos = exports.Token = exports.StableToken = void 0;
const base_1 = require("@celo/base");
const base_2 = require("./base");
var base_3 = require("@celo/base");
Object.defineProperty(exports, "StableToken", { enumerable: true, get: function () { return base_3.StableToken; } });
Object.defineProperty(exports, "Token", { enumerable: true, get: function () { return base_3.Token; } });
/** Basic info for each stable token */
exports.stableTokenInfos = {
    [base_1.StableToken.cUSD]: {
        contract: base_2.CeloContract.StableToken,
        symbol: base_1.StableToken.cUSD,
    },
    [base_1.StableToken.cEUR]: {
        contract: base_2.CeloContract.StableTokenEUR,
        symbol: base_1.StableToken.cEUR,
    },
    [base_1.StableToken.cREAL]: {
        contract: base_2.CeloContract.StableTokenBRL,
        symbol: base_1.StableToken.cREAL,
    },
};
/** Basic info for each supported celo token, including stable tokens */
exports.celoTokenInfos = Object.assign({ [base_1.Token.CELO]: {
        contract: base_2.CeloContract.GoldToken,
        symbol: base_1.Token.CELO,
    } }, exports.stableTokenInfos);
/**
 * A helper class to interact with all Celo tokens, ie CELO and stable tokens
 */
class CeloTokens {
    constructor(contracts, registry) {
        this.contracts = contracts;
        this.registry = registry;
        /**
         * Gets the address of the contract for the provided token.
         * @param token the token to get the (proxy) contract address for
         * @return A promise resolving to the address of the token's contract
         */
        this.getAddress = (token) => this.registry.addressFor(exports.celoTokenInfos[token].contract);
        this.isStableTokenContract = isStableTokenContract;
    }
    /**
     * Gets an address's balance for each celo token.
     * @param address the address to look up the balances for
     * @return a promise resolving to an object containing the address's balance
     *  for each celo token
     */
    balancesOf(address) {
        return this.forEachCeloToken((info) => __awaiter(this, void 0, void 0, function* () {
            const wrapper = yield this.contracts.getContract(info.contract);
            return wrapper.balanceOf(address);
        }));
    }
    /**
     * Gets the wrapper for each celo token.
     * @return an promise resolving to an object containing the wrapper for each celo token.
     */
    getWrappers() {
        return this.forEachCeloToken((info) => this.contracts.getContract(info.contract));
    }
    /**
     * Gets the address for each celo token proxy contract.
     * @return an promise resolving to an object containing the address for each celo token proxy.
     */
    getAddresses() {
        return this.forEachCeloToken((info) => this.registry.addressFor(info.contract));
    }
    getStablesConfigs(humanReadable = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.forStableCeloToken((info) => __awaiter(this, void 0, void 0, function* () {
                const stableWrapper = yield this.contracts.getContract(info.contract);
                if (humanReadable) {
                    return stableWrapper.getHumanReadableConfig();
                }
                return stableWrapper.getConfig();
            }));
        });
    }
    /**
     * Runs fn for each celo token found in celoTokenInfos, and returns the
     * value of each call in an object keyed by the token.
     * @param fn the function to be called for each CeloTokenInfo.
     * @return an object containing the resolved value the call to fn for each
     *  celo token.
     */
    forEachCeloToken(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            const wrapperInfoFunction = () => __awaiter(this, void 0, void 0, function* () {
                return Promise.all((yield this.validCeloTokenInfos()).map((info) => __awaiter(this, void 0, void 0, function* () {
                    const fnResult = fn(info);
                    return {
                        symbol: info.symbol,
                        data: yield fnResult,
                    };
                })));
            });
            return this.forEachWrapperInfo(wrapperInfoFunction);
        });
    }
    /**
     * Runs fn for each stable token found in stableTokenInfos, and returns the
     * value of each call in an object keyed by the token.
     * @param fn the function to be called for each StableTokenInfo.
     * @return an object containing the resolved value the call to fn for each
     *  celo token.
     */
    forStableCeloToken(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            const wrapperInfoFunction = () => __awaiter(this, void 0, void 0, function* () {
                return Promise.all((yield this.validStableTokenInfos()).map((info) => __awaiter(this, void 0, void 0, function* () {
                    const fnResult = fn(info);
                    return {
                        symbol: info.symbol,
                        data: yield fnResult,
                    };
                })));
            });
            return this.forEachWrapperInfo(wrapperInfoFunction);
        });
    }
    forEachWrapperInfo(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield fn()).reduce((obj, wrapperInfo) => (Object.assign(Object.assign({}, obj), { [wrapperInfo.symbol]: wrapperInfo.data })), {});
        });
    }
    validCeloTokenInfos() {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield Promise.all(Object.values(exports.celoTokenInfos).map((info) => __awaiter(this, void 0, void 0, function* () {
                try {
                    // The registry add the valid addresses to a cache
                    yield this.registry.addressFor(info.contract);
                    return true;
                }
                catch (_a) {
                    // The contract was not deployed in the chain
                    return false;
                }
            })));
            return Object.values(exports.celoTokenInfos).filter((_v, index) => results[index]);
        });
    }
    validStableTokenInfos() {
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield Promise.all(Object.values(exports.stableTokenInfos).map((info) => __awaiter(this, void 0, void 0, function* () {
                try {
                    // The registry add the valid addresses to a cache
                    yield this.registry.addressFor(info.contract);
                    return true;
                }
                catch (_a) {
                    // The contract was not deployed in the chain
                    return false;
                }
            })));
            return Object.values(exports.stableTokenInfos).filter((_v, index) => results[index]);
        });
    }
    getWrapper(token) {
        return this.contracts.getContract(exports.celoTokenInfos[token].contract);
    }
    getContract(token) {
        return exports.celoTokenInfos[token].contract;
    }
    /**
     * Gets the address to use as the feeCurrency when paying for gas with the
     *  provided token.
     * @param token the token to get the feeCurrency address for
     * @return If not CELO, the address of the token's contract. If CELO, undefined.
     */
    getFeeCurrencyAddress(token) {
        if (token === base_1.Token.CELO) {
            return undefined;
        }
        return this.getAddress(token);
    }
    /**
     * Returns if the provided token is a StableToken
     * @param token the token
     * @return if token is a StableToken
     */
    isStableToken(token) {
        // We cast token as StableToken to make typescript happy
        return Object.values(base_1.StableToken).includes(token);
    }
}
exports.CeloTokens = CeloTokens;
function isStableTokenContract(contract) {
    const allStableTokenContracts = Object.values(base_1.StableToken).map((token) => exports.stableTokenInfos[token].contract);
    // We cast token as StableTokenContract to make typescript happy
    return allStableTokenContracts.includes(contract);
}
exports.isStableTokenContract = isStableTokenContract;
//# sourceMappingURL=celo-tokens.js.map