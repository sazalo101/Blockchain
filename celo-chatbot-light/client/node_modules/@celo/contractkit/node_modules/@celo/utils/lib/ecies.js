/**
 * ECIES encrypt/decrypt with Ethereum keys
 * A Typescript implementation of geth/crypto/ecies/ecies.go
 * Modified from https://github.com/LimelabsTech/eth-ecies/blob/master/index.js
 * At commit c858cbd021e9a99d8afa629de33c8c30d923b3e5.
 */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.ECIES = exports.Decrypt = exports.Encrypt = exports.AES128DecryptAndHMAC = exports.AES128Decrypt = exports.AES128EncryptAndHMAC = exports.AES128Encrypt = exports.ConcatKDF = exports.IV_LENGTH = void 0;
const aes_1 = require("@noble/ciphers/aes");
const utils_1 = require("@noble/ciphers/utils");
const secp256k1_1 = require("@noble/curves/secp256k1");
const hmac_1 = require("@noble/hashes/hmac");
const sha256_1 = require("@noble/hashes/sha256");
const utils_2 = require("@noble/hashes/utils");
exports.IV_LENGTH = 16;
/**
 * Increments big endian uint32
 *
 * @param {Buffer} ctr 32 bit unsigned big endian integer to increment.
 * @returns Incremented counter.
 */
const IncCounter = (ctr) => {
    for (let i = ctr.length - 1; i >= 0; i--) {
        ctr[i]++;
        if (ctr[i] !== 0) {
            return ctr;
        }
    }
    return ctr;
};
/**
 * NIST 8000-56C Rev 1 One Step KDF with the following parameters:
 * - H(x) is SHA-256(x)
 * - Fixed info is null
 *
 * TODO:
 * - Implement proper ceiling on reps.
 *
 * @param {Buffer} px Input keying material to derive key from.
 * @param {number} kdLen Length of output in bytes
 * @returns {Buffer} Output keying material of length kdLen bytes.
 */
const ConcatKDF = (px, kdLen) => {
    const blockSize = 32;
    const reps = ((kdLen + 7) * 8) / (blockSize * 8);
    let counter = Buffer.from('00000001', 'hex');
    let k = Buffer.from('00', 'hex');
    for (let i = 0; i <= reps; i++) {
        const hash = sha256_1.sha256.create();
        hash.update(counter);
        hash.update(px);
        k = Buffer.concat([k, hash.digest()]);
        counter = IncCounter(counter);
    }
    return k.slice(1, kdLen + 1);
};
exports.ConcatKDF = ConcatKDF;
/**
 * AES-128 CTR encrypt
 * @param {Uint8Array} encryptionKey
 * @param {Uint8Array} iv
 * @param {Uint8Array} plaintext
 * @returns {Uint8Array} ciphertext
 */
function AES128Encrypt(encryptionKey, iv, plaintext) {
    const aes = (0, aes_1.ctr)(encryptionKey, iv);
    const message = aes.encrypt(plaintext);
    return (0, utils_1.u8)(Buffer.concat([iv, message]));
}
exports.AES128Encrypt = AES128Encrypt;
/**
 * AES-128 CTR encrypt with message authentication
 * @param {Uint8Array} encryptionKey
 * @param {Uint8Array} macKey
 *
 * @param {Uint8Array} plaintext
 * @returns {Uint8Array} ciphertext
 */
function AES128EncryptAndHMAC(encryptionKey, macKey, plaintext) {
    const iv = (0, utils_2.randomBytes)(exports.IV_LENGTH);
    const dataToMac = AES128Encrypt(encryptionKey, iv, plaintext);
    const mac = (0, hmac_1.hmac)(sha256_1.sha256, macKey, dataToMac);
    return (0, utils_1.u8)(Buffer.concat([dataToMac, mac]));
}
exports.AES128EncryptAndHMAC = AES128EncryptAndHMAC;
/**
 * AES-128 CTR decrypt
 * @param {Uint8Array} encryptionKey
 * @param {Uint8Array} iv
 * @param {Uint8Array} ciphertext
 * @returns {Uint8Array} plaintext
 */
function AES128Decrypt(encryptionKey, iv, ciphertext) {
    const aes = (0, aes_1.ctr)(encryptionKey, iv);
    return aes.decrypt(ciphertext);
}
exports.AES128Decrypt = AES128Decrypt;
/**
 * AES-128 CTR decrypt with message authentication
 * @param {Uint8Array} encryptionKey
 * @param {Uint8Array} macKey
 * @param {Uint8Array} ciphertext
 * @returns {Uint8Array} plaintext
 */
function AES128DecryptAndHMAC(encryptionKey, macKey, ciphertext) {
    const iv = ciphertext.slice(0, exports.IV_LENGTH);
    const message = ciphertext.slice(exports.IV_LENGTH, ciphertext.length - sha256_1.sha256.outputLen);
    const mac = ciphertext.slice(ciphertext.length - sha256_1.sha256.outputLen, ciphertext.length);
    const dataToMac = Buffer.concat([iv, message]);
    const computedMac = (0, hmac_1.hmac)(sha256_1.sha256, macKey, dataToMac);
    if (!Buffer.from(mac).equals(Buffer.from(computedMac))) {
        throw new Error('MAC mismatch');
    }
    return AES128Decrypt(encryptionKey, iv, message);
}
exports.AES128DecryptAndHMAC = AES128DecryptAndHMAC;
const UNCOMPRESSED_KEY_LENGTH = 65;
/**
 * ECIES encrypt
 * @param {Buffer} pubKeyTo Ethereum pub key, 64 bytes.
 * @param {Uint8Array} plaintext Plaintext to be encrypted.
 * @returns {Buffer} Encrypted message, serialized, 113+ bytes
 */
function Encrypt(pubKeyTo, plaintext) {
    const ephemPrivKey = secp256k1_1.secp256k1.utils.randomPrivateKey();
    const ephemPubKey = Buffer.from(secp256k1_1.secp256k1.getPublicKey(ephemPrivKey, false));
    const ephemPubKeyEncoded = Buffer.from(ephemPubKey);
    if (typeof pubKeyTo === 'string') {
        pubKeyTo = secp256k1_1.secp256k1.ProjectivePoint.fromHex(pubKeyTo).toRawBytes();
    }
    const pubKeyToEncoded = Buffer.concat([Buffer.from([0x04]), pubKeyTo]);
    const px = secp256k1_1.secp256k1.getSharedSecret(ephemPrivKey, pubKeyToEncoded).slice(1);
    // NOTE:
    // Can't swap to proper hkdf implementation because then there's ALWAYS a mac mismatch
    // for OLD comments. Maybe we should use a comment version?
    //
    // const hash = hkdf(sha256, px, undefined, undefined, 32)
    const hash = (0, exports.ConcatKDF)(Buffer.from(px), 32);
    const encryptionKey = hash.subarray(0, 16);
    const macKey = sha256_1.sha256.create().update(hash.subarray(16)).digest();
    const message = AES128EncryptAndHMAC(Buffer.from(encryptionKey), macKey, plaintext);
    const serializedCiphertext = Buffer.concat([
        ephemPubKeyEncoded, // {UNCOMPRESSED_KEY_LENGTH} bytes
        message, // iv + ciphertext + mac (min 48 bytes)
    ]);
    return serializedCiphertext;
}
exports.Encrypt = Encrypt;
/**
 * ECIES decrypt
 * @param {Buffer} privKey Ethereum private key, 32 bytes.
 * @param {Buffer} encrypted Encrypted message, serialized, 113+ bytes
 * @returns {Buffer} plaintext
 */
function Decrypt(privKey, encrypted) {
    // Read iv, ephemPubKey, mac, ciphertext from encrypted message
    const ephemPubKeyEncoded = (0, utils_1.u8)(encrypted).slice(0, UNCOMPRESSED_KEY_LENGTH);
    const symmetricEncrypted = (0, utils_1.u8)(encrypted).slice(UNCOMPRESSED_KEY_LENGTH);
    const px = secp256k1_1.secp256k1.getSharedSecret(privKey, ephemPubKeyEncoded).slice(1);
    // NOTE:
    // Can't swap to proper hkdf implementation because then there's ALWAYS a mac mismatch
    // for OLD comments. Maybe we should use a comment version?
    //
    // const hash = hkdf(sha256, px, undefined, undefined, 32)
    const hash = (0, exports.ConcatKDF)(Buffer.from(px), 32);
    // km, ke
    const encryptionKey = hash.subarray(0, 16);
    const macKey = sha256_1.sha256.create().update(hash.subarray(16)).digest();
    return AES128DecryptAndHMAC(Buffer.from(encryptionKey), macKey, symmetricEncrypted);
}
exports.Decrypt = Decrypt;
exports.ECIES = {
    Encrypt,
    Decrypt,
    AES128EncryptAndHMAC,
    AES128DecryptAndHMAC,
};
//# sourceMappingURL=ecies.js.map