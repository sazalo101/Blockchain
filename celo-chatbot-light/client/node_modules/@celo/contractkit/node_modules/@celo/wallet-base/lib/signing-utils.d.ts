/// <reference types="node" />
import { StrongAddress } from '@celo/base/lib/address';
import { CeloTx, EncodedTransaction, FormattedCeloTx, Hex, RLPEncodedTx, TransactionTypes } from '@celo/connect';
import { EIP712TypedData } from '@celo/utils/lib/sign-typed-data-utils';
import * as RLP from '@ethereumjs/rlp';
import { secp256k1 } from '@noble/curves/secp256k1';
import Web3 from 'web3';
type OldTransactionTypes = 'celo-legacy' | 'cip42' | TransactionTypes;
export declare const publicKeyPrefix: number;
export declare const sixtyFour: number;
export declare const thirtyTwo: number;
export declare function chainIdTransformationForSigning(chainId: number): number;
export declare function getHashFromEncoded(rlpEncode: StrongAddress): StrongAddress;
export declare function stringNumberOrBNToHex(num?: number | string | ReturnType<Web3['utils']['toBN']> | bigint): Hex;
export declare function rlpEncodedTx(tx: CeloTx): RLPEncodedTx;
declare enum TxTypeToPrefix {
    'ethereum-legacy' = "",
    'celo-legacy' = "",
    cip42 = "0x7c",
    cip64 = "0x7b",
    cip66 = "0x7a",
    eip1559 = "0x02"
}
export interface LegacyEncodedTx {
    type: 'celo-legacy';
    rlpEncode: `0x${string}`;
    transaction: FormattedCeloTx;
}
export declare function encode_deprecated_celo_legacy_type_only_for_temporary_ledger_compat(tx: CeloTx): LegacyEncodedTx;
export declare function isPriceToLow(tx: CeloTx): boolean;
export declare function isEIP1559(tx: CeloTx): boolean;
export declare function isCIP66(tx: CeloTx): boolean;
export declare function isCIP64(tx: CeloTx): boolean;
export declare function encodeTransaction(rlpEncoded: RLPEncodedTx | LegacyEncodedTx, signature: {
    v: number | bigint;
    r: Buffer;
    s: Buffer;
}): Promise<EncodedTransaction>;
declare function prefixAwareRLPDecode(rlpEncode: string, type: OldTransactionTypes): Uint8Array | RLP.NestedUint8Array;
export declare function extractSignature(rawTx: string): {
    v: `0x${string}`;
    r: `0x${string}`;
    s: `0x${string}`;
};
export declare function recoverTransaction(rawTx: string): [CeloTx, string];
export declare function getSignerFromTxEIP2718TX(serializedTransaction: string): string;
export declare function determineTXType(serializedTransaction: string): OldTransactionTypes;
declare function vrsForRecovery(vRaw: string, r: string, s: string): {
    readonly v: number;
    readonly r: string;
    readonly s: string;
    readonly yParity: 0 | 1;
};
export declare function recoverMessageSigner(signingDataHex: string, signedData: string): string;
export declare function verifyEIP712TypedDataSigner(typedData: EIP712TypedData, signedData: string, expectedAddress: string): boolean;
export declare function verifySignatureWithoutPrefix(messageHash: string, signature: string, signer: string): boolean;
export declare function decodeSig(sig: StrongAddress | ReturnType<typeof secp256k1.sign>, addToV?: number): {
    v: number;
    r: Buffer;
    s: Buffer;
};
export declare function extractPublicKeyFromHashAndSignature({ r, s, yParity }: ReturnType<typeof vrsForRecovery>, data: ReturnType<typeof prefixAwareRLPDecode>, _prefix: TxTypeToPrefix): string;
export declare function signTransaction(hash: StrongAddress, privateKey: StrongAddress, addToV?: number): {
    v: number;
    r: Buffer;
    s: Buffer;
};
export declare function handleNumber(n: Uint8Array): number;
export declare function handleStringNumber(n: Uint8Array): string;
export declare function handleBigInt(n: Uint8Array): bigint;
export declare function handleHexString(adr: Uint8Array): StrongAddress;
export declare function handleData(data: Uint8Array): string;
export declare function assertLength(transactionArray: ReturnType<typeof prefixAwareRLPDecode>, type: TransactionTypes): void;
export {};
