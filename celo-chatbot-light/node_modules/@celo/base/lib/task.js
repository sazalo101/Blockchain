"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryObtainValueWithRetries = exports.conditionWatcher = exports.repeatTask = void 0;
const future_1 = require("./future");
const logger_1 = require("./logger");
/**
 * Given task options, creates the task logger
 *
 * It will prefix taskName to the logs
 */
const createTaskLogger = (opts) => {
    return opts.logger ? (0, logger_1.prefixLogger)(opts.name, opts.logger) : logger_1.noopLogger;
};
/**
 * Runs an async function eternally until stopped
 *
 * @param fn function to run
 */
function repeatTask(opts, fn) {
    const logger = createTaskLogger(opts);
    let isActive = true;
    const ctx = {
        executionNumber: 0,
        stopTask: () => {
            isActive = false;
        },
    };
    const loop = () => __awaiter(this, void 0, void 0, function* () {
        if (!isActive) {
            return;
        }
        try {
            ctx.executionNumber++;
            yield fn(ctx);
        }
        catch (err) {
            logger(`Failed with error: ${err.message}`);
            logger(err);
        }
        finally {
            if (isActive) {
                setTimeout(loop, opts.timeInBetweenMS);
            }
        }
    });
    if (opts.initialDelayMS != null) {
        setTimeout(loop, opts.initialDelayMS);
    }
    else {
        void loop();
    }
    return {
        stop: ctx.stopTask,
        isRunning: () => isActive,
    };
}
exports.repeatTask = repeatTask;
function conditionWatcher(opts) {
    return repeatTask(opts, (ctx) => __awaiter(this, void 0, void 0, function* () {
        const val = yield opts.pollCondition();
        if (val) {
            ctx.stopTask();
            yield opts.onSuccess();
        }
    }));
}
exports.conditionWatcher = conditionWatcher;
function tryObtainValueWithRetries(opts) {
    const futureValue = new future_1.Future();
    const task = repeatTask(opts, (ctx) => __awaiter(this, void 0, void 0, function* () {
        if (ctx.executionNumber > opts.maxAttemps) {
            ctx.stopTask();
            futureValue.reject(new Error('Max Retries & no value'));
        }
        else {
            const val = yield opts.tryGetValue();
            if (val != null) {
                futureValue.resolve(val);
                ctx.stopTask();
            }
        }
    }));
    return Object.assign(Object.assign({}, task), { stop: () => {
            task.stop();
            futureValue.reject(new Error('Cancelled'));
        }, onValue: () => futureValue.asPromise() });
}
exports.tryObtainValueWithRetries = tryObtainValueWithRetries;
//# sourceMappingURL=task.js.map