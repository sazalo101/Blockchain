"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trimUncompressedPrefix = exports.ensureUncompressed = exports.ensureCompressed = exports.isCompressed = exports.computeSharedSecret = void 0;
const address_1 = require("@celo/base/lib/address");
const secp256k1_1 = require("@noble/curves/secp256k1");
function computeSharedSecret(privateKey, publicKey) {
    return Buffer.from(secp256k1_1.secp256k1.getSharedSecret(Buffer.from((0, address_1.trimLeading0x)(privateKey), 'hex'), Buffer.from(ensureCompressed(publicKey), 'hex')));
}
exports.computeSharedSecret = computeSharedSecret;
function isCompressed(publicKey) {
    const noLeading0x = (0, address_1.trimLeading0x)(publicKey);
    if (noLeading0x.length === 64) {
        return true;
    }
    return noLeading0x.length === 66 && (noLeading0x.startsWith('02') || noLeading0x.startsWith('03'));
}
exports.isCompressed = isCompressed;
function ensureCompressed(publicKey) {
    return Buffer.from(secp256k1_1.secp256k1.getSharedSecret(BigInt(1), Buffer.from(publicKey, 'hex'))).toString('hex');
}
exports.ensureCompressed = ensureCompressed;
function ensureUncompressed(publicKey) {
    const noLeading0x = (0, address_1.trimLeading0x)(publicKey);
    return secp256k1_1.secp256k1.getSharedSecret(BigInt(1), Buffer.from(noLeading0x, 'hex'), false);
}
exports.ensureUncompressed = ensureUncompressed;
function trimUncompressedPrefix(publicKey) {
    const noLeading0x = (0, address_1.trimLeading0x)(publicKey);
    if (noLeading0x.length === 130 && noLeading0x.startsWith('04')) {
        return noLeading0x.slice(2);
    }
    return noLeading0x;
}
exports.trimUncompressedPrefix = trimUncompressedPrefix;
//# sourceMappingURL=ecdh.js.map