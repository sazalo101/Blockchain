"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignatureUtils = exports.guessSigner = exports.verifyEIP712TypedDataSigner = exports.recoverEIP712TypedDataSignerVrs = exports.recoverEIP712TypedDataSignerRsv = exports.parseSignatureWithoutPrefix = exports.parseSignature = exports.verifySignature = exports.signMessageWithoutPrefix = exports.signMessage = exports.signedMessageToPublicKey = exports.LocalSigner = exports.addressToPublicKey = exports.hashMessage = exports.hashMessageWithPrefix = exports.serializeSignature = exports.POP_SIZE = exports.NativeSigner = void 0;
const signatureUtils_1 = require("@celo/base/lib/signatureUtils");
const util_1 = require("@ethereumjs/util");
const web3_utils_1 = require("web3-utils");
const address_1 = require("./address");
const sign_typed_data_utils_1 = require("./sign-typed-data-utils");
// Exports moved to @celo/base, forwarding them
// here for backwards compatibility
var signatureUtils_2 = require("@celo/base/lib/signatureUtils");
Object.defineProperty(exports, "NativeSigner", { enumerable: true, get: function () { return signatureUtils_2.NativeSigner; } });
Object.defineProperty(exports, "POP_SIZE", { enumerable: true, get: function () { return signatureUtils_2.POP_SIZE; } });
Object.defineProperty(exports, "serializeSignature", { enumerable: true, get: function () { return signatureUtils_2.serializeSignature; } });
// If messages is a hex, the length of it should be the number of bytes
function messageLength(message) {
    if ((0, web3_utils_1.isHexStrict)(message)) {
        return (message.length - 2) / 2;
    }
    return message.length;
}
// Ethereum has a special signature format that requires a prefix
// https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
function hashMessageWithPrefix(message) {
    const prefix = '\x19Ethereum Signed Message:\n' + messageLength(message);
    return (0, web3_utils_1.soliditySha3)(prefix, message);
}
exports.hashMessageWithPrefix = hashMessageWithPrefix;
function hashMessage(message) {
    return (0, web3_utils_1.soliditySha3)({ type: 'string', value: message });
}
exports.hashMessage = hashMessage;
function addressToPublicKey(signer, signFn) {
    return __awaiter(this, void 0, void 0, function* () {
        const msg = Buffer.from('dummy_msg_data');
        const data = '0x' + msg.toString('hex');
        // Note: Eth.sign typing displays incorrect parameter order
        const sig = yield signFn(data, signer);
        const rawsig = (0, util_1.fromRpcSig)(sig);
        const prefixedMsg = hashMessageWithPrefix(data);
        const pubKey = (0, util_1.ecrecover)(Buffer.from(prefixedMsg.slice(2), 'hex'), rawsig.v, rawsig.r, rawsig.s);
        const computedAddr = (0, util_1.pubToAddress)(pubKey).toString('hex');
        if (!(0, address_1.eqAddress)(computedAddr, signer)) {
            throw new Error('computed address !== signer');
        }
        return '0x' + pubKey.toString('hex');
    });
}
exports.addressToPublicKey = addressToPublicKey;
function LocalSigner(privateKey) {
    return {
        sign: (message) => __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve((0, signatureUtils_1.serializeSignature)(signMessage(message, privateKey, (0, address_1.privateKeyToAddress)(privateKey))));
        }),
    };
}
exports.LocalSigner = LocalSigner;
function signedMessageToPublicKey(message, v, r, s) {
    const pubKeyBuf = (0, util_1.ecrecover)(Buffer.from(message.slice(2), 'hex'), BigInt(v), Buffer.from(r.slice(2), 'hex'), Buffer.from(s.slice(2), 'hex'));
    return '0x' + pubKeyBuf.toString('hex');
}
exports.signedMessageToPublicKey = signedMessageToPublicKey;
function signMessage(message, privateKey, address) {
    return signMessageWithoutPrefix(hashMessageWithPrefix(message), (0, address_1.ensureLeading0x)(privateKey), address);
}
exports.signMessage = signMessage;
function signMessageWithoutPrefix(messageHash, privateKey, address) {
    const publicKey = (0, util_1.privateToPublic)((0, util_1.toBuffer)(privateKey));
    const derivedAddress = (0, util_1.bufferToHex)((0, util_1.pubToAddress)(publicKey));
    if (derivedAddress.toLowerCase() !== address.toLowerCase()) {
        throw new Error('Provided private key does not match address of intended signer');
    }
    const { r, s, v } = (0, util_1.ecsign)((0, util_1.toBuffer)(messageHash), (0, util_1.toBuffer)(privateKey));
    if (!isValidSignature(address, messageHash, Number(v), (0, util_1.bufferToHex)(r), (0, util_1.bufferToHex)(s))) {
        throw new Error('Unable to validate signature');
    }
    return { v: Number(v), r: (0, util_1.bufferToHex)(r), s: (0, util_1.bufferToHex)(s) };
}
exports.signMessageWithoutPrefix = signMessageWithoutPrefix;
function verifySignature(message, signature, signer) {
    try {
        parseSignature(message, signature, signer);
        return true;
    }
    catch (error) {
        return false;
    }
}
exports.verifySignature = verifySignature;
function parseSignature(message, signature, signer) {
    return parseSignatureWithoutPrefix(hashMessageWithPrefix(message), signature, signer);
}
exports.parseSignature = parseSignature;
function parseSignatureWithoutPrefix(messageHash, signature, signer) {
    let { r, s, v } = parseSignatureAsRsv(signature.slice(2));
    if (isValidSignature(signer, messageHash, v, r, s)) {
        return { v, r, s };
    }
    ;
    ({ r, s, v } = parseSignatureAsVrs(signature.slice(2)));
    if (isValidSignature(signer, messageHash, v, r, s)) {
        return { v, r, s };
    }
    throw new Error(`Unable to parse signature (expected signer ${signer})`);
}
exports.parseSignatureWithoutPrefix = parseSignatureWithoutPrefix;
function recoverEIP712TypedDataSigner(typedData, signature, parseFunction) {
    const dataBuff = (0, sign_typed_data_utils_1.generateTypedDataHash)(typedData);
    const { r, s, v } = parseFunction((0, address_1.trimLeading0x)(signature));
    const publicKey = (0, util_1.ecrecover)((0, util_1.toBuffer)(dataBuff), BigInt(v), (0, util_1.toBuffer)(r), (0, util_1.toBuffer)(s));
    // TODO test error handling on this
    return (0, util_1.bufferToHex)((0, util_1.pubToAddress)(publicKey));
}
/**
 * Recover signer from RSV-serialized signature over signed typed data.
 * @param typedData EIP712 typed data
 * @param signature RSV signature of signed type data by signer
 * @returns string signer, or throws error if parsing fails
 */
function recoverEIP712TypedDataSignerRsv(typedData, signature) {
    return recoverEIP712TypedDataSigner(typedData, signature, parseSignatureAsRsv);
}
exports.recoverEIP712TypedDataSignerRsv = recoverEIP712TypedDataSignerRsv;
/**
 * Recover signer from VRS-serialized signature over signed typed data.
 * @param typedData EIP712 typed data
 * @param signature VRS signature of signed type data by signer
 * @returns string signer, or throws error if parsing fails
 */
function recoverEIP712TypedDataSignerVrs(typedData, signature) {
    return recoverEIP712TypedDataSigner(typedData, signature, parseSignatureAsVrs);
}
exports.recoverEIP712TypedDataSignerVrs = recoverEIP712TypedDataSignerVrs;
/**
 * @param typedData EIP712 typed data
 * @param signature VRS or SRV signature of `typedData` by `signer`
 * @param signer address to verify signed the `typedData`
 * @returns boolean, true if `signer` is a possible signer of `signature`
 */
function verifyEIP712TypedDataSigner(typedData, signature, signer) {
    for (const recover of [recoverEIP712TypedDataSignerVrs, recoverEIP712TypedDataSignerRsv]) {
        try {
            if ((0, address_1.eqAddress)(recover(typedData, signature), signer)) {
                return true;
            }
        }
        catch (e) {
            // try both serialization formats before failing to verify
        }
    }
    return false;
}
exports.verifyEIP712TypedDataSigner = verifyEIP712TypedDataSigner;
function guessSigner(message, signature) {
    const messageHash = hashMessageWithPrefix(message);
    const { r, s, v } = parseSignatureAsRsv(signature.slice(2));
    const publicKey = (0, util_1.ecrecover)((0, util_1.toBuffer)(messageHash), BigInt(v), (0, util_1.toBuffer)(r), (0, util_1.toBuffer)(s));
    return (0, util_1.bufferToHex)((0, util_1.pubToAddress)(publicKey));
}
exports.guessSigner = guessSigner;
function parseSignatureAsVrs(signature) {
    let v = parseInt(signature.slice(0, 2), 16);
    const r = `0x${signature.slice(2, 66)}`;
    const s = `0x${signature.slice(66, 130)}`;
    if (v < 27) {
        v += 27;
    }
    return { v, r, s };
}
function parseSignatureAsRsv(signature) {
    const r = `0x${signature.slice(0, 64)}`;
    const s = `0x${signature.slice(64, 128)}`;
    let v = parseInt(signature.slice(128, 130), 16);
    if (v < 27) {
        v += 27;
    }
    return { r, s, v };
}
function isValidSignature(signer, message, v, r, s) {
    try {
        const publicKey = (0, util_1.ecrecover)((0, util_1.toBuffer)(message), BigInt(v), (0, util_1.toBuffer)(r), (0, util_1.toBuffer)(s));
        const retrievedAddress = (0, util_1.bufferToHex)((0, util_1.pubToAddress)(publicKey));
        return (0, address_1.eqAddress)(retrievedAddress, signer);
    }
    catch (err) {
        return false;
    }
}
exports.SignatureUtils = {
    NativeSigner: signatureUtils_1.NativeSigner,
    LocalSigner,
    signMessage,
    signMessageWithoutPrefix,
    parseSignature,
    parseSignatureWithoutPrefix,
    serializeSignature: signatureUtils_1.serializeSignature,
    recoverEIP712TypedDataSignerRsv,
    recoverEIP712TypedDataSignerVrs,
    verifyEIP712TypedDataSigner,
};
//# sourceMappingURL=signatureUtils.js.map