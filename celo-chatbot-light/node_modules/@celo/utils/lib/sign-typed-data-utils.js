"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.zeroValue = exports.structHash = exports.encodeData = exports.typeHash = exports.encodeType = exports.generateTypedDataHash = exports.noString = exports.noNumber = exports.noBool = exports.defined = exports.eip712OptionalSchema = exports.eip712OptionalType = exports.EIP712_BUILTIN_TYPES = exports.EIP712_DYNAMIC_TYPES = exports.EIP712_ATOMIC_TYPES = void 0;
const address_1 = require("@celo/base/lib/address");
const sha3_1 = require("@noble/hashes/sha3");
const utils_1 = require("@noble/hashes/utils");
const bignumber_js_1 = require("bignumber.js");
const t = __importStar(require("io-ts"));
const web3_eth_abi_1 = __importDefault(require("web3-eth-abi"));
/** Array of all EIP-712 atomic type names. */
exports.EIP712_ATOMIC_TYPES = [
    'bool',
    'address',
    // bytes types from 1 to 32 bytes
    // and uint/int types from 8 to 256 bits
    ...(() => {
        const result = [];
        // Putting "bigger" types first, assuming they are more likely to be used.
        // So `EIP712_ATOMIC_TYPES.includes(...)` calls are faster. (likely useless micro-optimization :D)
        for (let i = 32; i >= 1; i--) {
            result.push('bytes' + i);
            result.push('uint' + i * 8);
            result.push('int' + i * 8);
        }
        return result;
    })(),
];
exports.EIP712_DYNAMIC_TYPES = ['bytes', 'string'];
exports.EIP712_BUILTIN_TYPES = exports.EIP712_DYNAMIC_TYPES.concat(exports.EIP712_ATOMIC_TYPES);
// Regular expression used to identify and parse EIP-712 array type strings.
const EIP712_ARRAY_REGEXP = /^(?<memberType>[\w<>\[\]_\-]+)(\[(?<fixedLength>\d+)?\])$/;
// Regular expression used to identify EIP-712 integer types (e.g. int256, uint256, uint8).
const EIP712_INT_REGEXP = /^u?int\d*$/;
// Regular expression used to identify EIP-712 bytes types (e.g. bytes, bytes1, up to bytes32).
const EIP712_BYTES_REGEXP = /^bytes\d*$/;
/**
 * Utility to build EIP712Optional<T> types to insert in EIP-712 type arrays.
 * @param typeName EIP-712 string type name. Should be builtin or defined in the EIP712Types
 * structure into which this type will be merged.
 */
const eip712OptionalType = (typeName) => ({
    [`Optional<${typeName}>`]: [
        { name: 'defined', type: 'bool' },
        { name: 'value', type: typeName },
    ],
});
exports.eip712OptionalType = eip712OptionalType;
/**
 * Utility to build EIP712Optional<T> schemas for encoding and decoding with io-ts.
 * @param schema io-ts type (a.k.a. schema or codec) describing the inner type.
 */
const eip712OptionalSchema = (schema) => t.type({
    defined: t.boolean,
    value: schema,
});
exports.eip712OptionalSchema = eip712OptionalSchema;
/** Utility to construct an defined EIP712Optional value with inferred type. */
const defined = (value) => ({
    defined: true,
    value,
});
exports.defined = defined;
/** Undefined EIP712Optional type with value type boolean. */
exports.noBool = {
    defined: false,
    value: false,
};
/** Undefined EIP712Optional type with value type number. */
exports.noNumber = {
    defined: false,
    value: 0,
};
/** Undefined EIP712Optional type with value type string. */
exports.noString = {
    defined: false,
    value: '',
};
/**
 * Generates the EIP712 Typed Data hash for signing
 * @param   typedData An object that conforms to the EIP712TypedData interface
 * @return  A Buffer containing the hash of the typed data.
 */
function generateTypedDataHash(typedData) {
    return Buffer.from((0, sha3_1.keccak_256)(Buffer.concat([
        Buffer.from('1901', 'hex'),
        structHash('EIP712Domain', typedData.domain, typedData.types),
        structHash(typedData.primaryType, typedData.message, typedData.types),
    ])));
}
exports.generateTypedDataHash = generateTypedDataHash;
/**
 * Given the primary type, and dictionary of types, this function assembles a sorted list
 * representing the transitive dependency closure of the primary type. (Inclusive of the primary
 * type itself.)
 */
function findDependencies(primaryType, types, found = []) {
    var _a;
    // If we have aready found the dependencies of this type, or it is a builtin, return early.
    if (found.includes(primaryType) || exports.EIP712_BUILTIN_TYPES.includes(primaryType)) {
        return [];
    }
    // If this is an array type, return the results for its member type.
    if (EIP712_ARRAY_REGEXP.test(primaryType)) {
        const match = EIP712_ARRAY_REGEXP.exec(primaryType);
        const memberType = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;
        return findDependencies(memberType, types, found);
    }
    // If this is not a builtin and is not defined, we cannot correctly construct a type encoding.
    if (types[primaryType] === undefined) {
        throw new Error(`Unrecognized type ${primaryType} is not included in the EIP-712 type list`);
    }
    // Execute a depth-first search to populate the (inclusive) dependencies list.
    // By the first invarient of this function, the resulting list should not contain duplicates.
    const dependencies = [primaryType];
    for (const field of types[primaryType]) {
        dependencies.push(...findDependencies(field.type, types, found.concat(dependencies)));
    }
    return dependencies;
}
/**
 * Creates a string encoding of the primary type, including all dependencies.
 * E.g. "Transaction(Person from,Person to,Asset tx)Asset(address token,uint256 amount)Person(address wallet,string name)"
 */
function encodeType(primaryType, types) {
    let deps = findDependencies(primaryType, types);
    deps = deps.filter((d) => d !== primaryType);
    deps = [primaryType].concat(deps.sort());
    let result = '';
    for (const dep of deps) {
        result += `${dep}(${types[dep].map(({ name, type }) => `${type} ${name}`).join(',')})`;
    }
    return result;
}
exports.encodeType = encodeType;
function typeHash(primaryType, types) {
    return Buffer.from((0, sha3_1.keccak_256)((0, utils_1.utf8ToBytes)(encodeType(primaryType, types))));
}
exports.typeHash = typeHash;
/** Encodes a single EIP-712 value to a 32-byte buffer */
function encodeValue(valueType, value, types) {
    var _a;
    // Encode the atomic types as their corresponding soldity ABI type.
    if (exports.EIP712_ATOMIC_TYPES.includes(valueType)) {
        const hexEncoded = web3_eth_abi_1.default.encodeParameter(valueType, normalizeValue(valueType, value));
        return Buffer.from((0, address_1.trimLeading0x)(hexEncoded), 'hex');
    }
    // Encode `string` and `bytes` types as their keccak hash.
    if (valueType === 'string') {
        // Converting to Buffer before passing to `keccak` prevents an issue where the string is
        // interpretted as a hex-encoded string when is starts with 0x.
        // https://github.com/ethereumjs/ethereumjs-util/blob/7e3be1d97b4e11fbc4924836b8c444e644f643ac/index.js#L155-L183
        return Buffer.from((0, sha3_1.keccak_256)(Buffer.from(value, 'utf8')));
    }
    if (valueType === 'bytes') {
        // Allow the user to use either utf8 (plain string) or hex encoding for their bytes.
        // Note: keccak throws if the value cannot be converted into a Buffer,
        return Buffer.from((0, sha3_1.keccak_256)((0, utils_1.hexToBytes)((0, address_1.trimLeading0x)(value))));
    }
    // Encode structs as its hashStruct (e.g. keccak(typeHash || encodeData(struct)) ).
    if (types[valueType] !== undefined) {
        return structHash(valueType, value, types);
    }
    // Encode arrays as the hash of the concatenated encoding of the underlying types.
    if (EIP712_ARRAY_REGEXP.test(valueType)) {
        // Note: If a fixed length is provided in the type, it is not checked.
        const match = EIP712_ARRAY_REGEXP.exec(valueType);
        const memberType = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;
        return Buffer.from((0, sha3_1.keccak_256)(Buffer.concat(value.map((member) => encodeValue(memberType, member, types)))));
    }
    throw new Error(`Unrecognized or unsupported type in EIP-712 encoding: ${valueType}`);
}
function normalizeValue(type, value) {
    const normalizedValue = EIP712_INT_REGEXP.test(type) && bignumber_js_1.BigNumber.isBigNumber(value) ? value.toString() : value;
    return normalizedValue;
}
/**
 * Constructs the struct encoding of the data as the primary type.
 */
function encodeData(primaryType, data, types) {
    const fields = types[primaryType];
    if (fields === undefined) {
        throw new Error(`Unrecognized primary type in EIP-712 encoding: ${primaryType}`);
    }
    return Buffer.concat(fields.map((field) => encodeValue(field.type, data[field.name], types)));
}
exports.encodeData = encodeData;
function structHash(primaryType, data, types) {
    return Buffer.from((0, sha3_1.keccak_256)(Buffer.concat([typeHash(primaryType, types), encodeData(primaryType, data, types)])));
}
exports.structHash = structHash;
/**
 * Produce the zero value for a given type.
 *
 * @remarks
 * All atomic types will encode as the 32-byte zero value. Dynamic types as an empty hash.
 * Dynamic arrays will return an empty array. Fixed length arrays will have members set to zero.
 * Structs will have the values of all fields set to zero recursively.
 *
 * Note that EIP-712 does not specify zero values, and so this is non-standard.
 */
function zeroValue(primaryType, types = {}) {
    var _a, _b;
    // If the type is a built-in, return a pre-defined zero value.
    if (exports.EIP712_BUILTIN_TYPES.includes(primaryType)) {
        if (EIP712_BYTES_REGEXP.test(primaryType)) {
            return Buffer.alloc(0);
        }
        if (EIP712_INT_REGEXP.test(primaryType)) {
            return 0;
        }
        if (primaryType === 'bool') {
            return false;
        }
        if (primaryType === 'address') {
            return address_1.NULL_ADDRESS;
        }
        if (primaryType === 'string') {
            return '';
        }
    }
    // If the type is an array, return an empty array or an array of the given fixed length.
    if (EIP712_ARRAY_REGEXP.test(primaryType)) {
        const match = EIP712_ARRAY_REGEXP.exec(primaryType);
        const memberType = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;
        const fixedLengthStr = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.fixedLength;
        const fixedLength = fixedLengthStr === undefined ? 0 : parseInt(fixedLengthStr, 10);
        return [...Array(fixedLength).keys()].map(() => zeroValue(memberType, types));
    }
    // Must be user-defined type. Return an object with all fields set to their zero value.
    const fields = types[primaryType];
    if (fields === undefined) {
        throw new Error(`Unrecognized primary type for EIP-712 zero value: ${primaryType}`);
    }
    return fields.reduce((obj, field) => (Object.assign(Object.assign({}, obj), { [field.name]: zeroValue(field.type, types) })), {});
}
exports.zeroValue = zeroValue;
//# sourceMappingURL=sign-typed-data-utils.js.map