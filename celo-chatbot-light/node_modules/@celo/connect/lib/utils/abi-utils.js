"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeStringParameter = exports.signatureToAbiDefinition = exports.parseDecodedParams = exports.getAbiByName = void 0;
const address_1 = require("@celo/base/lib/address");
/** @internal */
const getAbiByName = (abi, methodName) => abi.find((entry) => entry.name === methodName);
exports.getAbiByName = getAbiByName;
/** @internal */
const parseDecodedParams = (params) => {
    const args = new Array(params.__length__);
    Object.keys(params).forEach((key) => {
        if (key === '__length__') {
            return;
        }
        const argIndex = parseInt(key, 10);
        if (argIndex >= 0) {
            args[argIndex] = params[key];
            delete params[key];
        }
    });
    return { args, params };
};
exports.parseDecodedParams = parseDecodedParams;
/**
 * Parses solidity function signature
 * @dev
 * example of input function signature: transfer(address,uint256)
 * example of output structure can be found in propose.test.ts variable `structAbiDefinition`
 * supports tuples eg. mint(uint256, (uint256, uint256))
 * and structs eg. mint(uint256, (uint256 a, uint256 b))
 * @param fnSignature The function signature
 * @returns AbiItem structure that can be used to encode/decode
 */
const signatureToAbiDefinition = (fnSignature) => {
    const matches = /(?<method>[^\(]+)\((?<args>.*)\)/.exec(fnSignature);
    if (matches == null) {
        throw new Error(`${fnSignature} is malformed`);
    }
    const method = matches.groups.method;
    const argRegex = /\(((?:[^()]+|\((?:[^()]+|\([^()]*\))*\))*)\)|(\b\w+\b(?:(?:\s+\w+)?))/g;
    const args = [...matches.groups.args.matchAll(argRegex)].map((match) => match[1] ? `(${match[1]})` : match[2]);
    const inputs = args.map((arg, index) => {
        var _a;
        if (arg.indexOf('(') == 0) {
            // tuple or struct
            const tupleArgs = arg
                .substring(1, arg.length - 1)
                .split(',')
                .map((a) => a.trim());
            const components = tupleArgs.map((type, tupleIndex) => {
                var _a;
                const parts = type
                    .trim()
                    .split(' ')
                    .map((p) => p.trim());
                if (parts.length > 2) {
                    throw new Error(`${fnSignature} is malformed`);
                }
                return {
                    type: parts[0],
                    name: (_a = parts[1]) !== null && _a !== void 0 ? _a : `a${index}-${tupleIndex}`,
                };
            });
            return {
                name: 'params',
                type: 'tuple',
                components: components,
            };
        }
        else {
            const parts = arg
                .trim()
                .split(' ')
                .map((p) => p.trim());
            if (parts.length > 2) {
                throw new Error(`${fnSignature} is malformed`);
            }
            return {
                type: parts[0],
                name: (_a = parts[1]) !== null && _a !== void 0 ? _a : `a${index}`,
            };
        }
    });
    return {
        name: method,
        signature: fnSignature,
        type: 'function',
        inputs,
    };
};
exports.signatureToAbiDefinition = signatureToAbiDefinition;
/** @internal */
const decodeStringParameter = (ethAbi, str) => ethAbi.decodeParameter('string', (0, address_1.ensureLeading0x)(str));
exports.decodeStringParameter = decodeStringParameter;
//# sourceMappingURL=abi-utils.js.map