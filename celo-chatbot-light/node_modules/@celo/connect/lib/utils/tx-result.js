"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionResult = exports.toTxResult = void 0;
const future_1 = require("@celo/base/lib/future");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)('connection:tx:result');
/**
 * Transforms a `PromiEvent` to a `TransactionResult`.
 */
function toTxResult(pe) {
    return new TransactionResult(pe);
}
exports.toTxResult = toTxResult;
/**
 * Replacement interface for web3's `PromiEvent`. Instead of emiting events
 * to signal different stages, eveything is exposed as a promise. Which ends
 * up being nicer when doing promise/async based programming.
 */
class TransactionResult {
    constructor(pe) {
        this.hashFuture = new future_1.Future();
        this.receiptFuture = new future_1.Future();
        void pe
            .on('transactionHash', (hash) => {
            debug('hash: %s', hash);
            this.hashFuture.resolve(hash);
        })
            .on('receipt', (receipt) => {
            debug('receipt: %O', receipt);
            this.receiptFuture.resolve(receipt);
        })
            .on('error', ((error, receipt) => {
            if (!receipt) {
                debug('send-error: %o', error);
                this.hashFuture.reject(error);
            }
            else {
                debug('mining-error: %o, %O', error, receipt);
            }
            this.receiptFuture.reject(error);
        }));
    }
    /** Get (& wait for) transaction hash */
    getHash() {
        return this.hashFuture.wait().catch((err) => {
            // if hashFuture fails => receiptFuture also fails
            // we wait for it here; so not UnhandlePromise error occurrs
            this.receiptFuture.wait().catch(() => {
                // ignore
            });
            throw err;
        });
    }
    /** Get (& wait for) transaction receipt */
    waitReceipt() {
        return __awaiter(this, void 0, void 0, function* () {
            // Make sure `getHash()` promise is consumed
            yield this.getHash();
            return this.receiptFuture.wait();
        });
    }
}
exports.TransactionResult = TransactionResult;
//# sourceMappingURL=tx-result.js.map