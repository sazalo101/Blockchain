"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WrapperCache = void 0;
const base_1 = require("./base");
const celo_tokens_1 = require("./celo-tokens");
const Accounts_1 = require("./wrappers/Accounts");
const Attestations_1 = require("./wrappers/Attestations");
const BlockchainParameters_1 = require("./wrappers/BlockchainParameters");
const CeloDistributionScheduleWrapper_1 = require("./wrappers/CeloDistributionScheduleWrapper");
const DoubleSigningSlasher_1 = require("./wrappers/DoubleSigningSlasher");
const DowntimeSlasher_1 = require("./wrappers/DowntimeSlasher");
const Election_1 = require("./wrappers/Election");
const EpochRewards_1 = require("./wrappers/EpochRewards");
const Erc20Wrapper_1 = require("./wrappers/Erc20Wrapper");
const Escrow_1 = require("./wrappers/Escrow");
const FederatedAttestations_1 = require("./wrappers/FederatedAttestations");
const FeeCurrencyDirectoryWrapper_1 = require("./wrappers/FeeCurrencyDirectoryWrapper");
const FeeCurrencyWhitelistWrapper_1 = require("./wrappers/FeeCurrencyWhitelistWrapper");
const Freezer_1 = require("./wrappers/Freezer");
const GasPriceMinimum_1 = require("./wrappers/GasPriceMinimum");
const GoldTokenWrapper_1 = require("./wrappers/GoldTokenWrapper");
const Governance_1 = require("./wrappers/Governance");
const LockedGold_1 = require("./wrappers/LockedGold");
const MultiSig_1 = require("./wrappers/MultiSig");
const OdisPayments_1 = require("./wrappers/OdisPayments");
const Reserve_1 = require("./wrappers/Reserve");
const SortedOracles_1 = require("./wrappers/SortedOracles");
const StableTokenWrapper_1 = require("./wrappers/StableTokenWrapper");
const Validators_1 = require("./wrappers/Validators");
const WrapperFactories = {
    [base_1.CeloContract.Accounts]: Accounts_1.AccountsWrapper,
    [base_1.CeloContract.BlockchainParameters]: BlockchainParameters_1.BlockchainParametersWrapper,
    [base_1.CeloContract.CeloDistributionSchedule]: CeloDistributionScheduleWrapper_1.CeloDistributionScheduleWrapper,
    [base_1.CeloContract.EpochRewards]: EpochRewards_1.EpochRewardsWrapper,
    [base_1.CeloContract.ERC20]: Erc20Wrapper_1.Erc20Wrapper,
    [base_1.CeloContract.Escrow]: Escrow_1.EscrowWrapper,
    [base_1.CeloContract.FederatedAttestations]: FederatedAttestations_1.FederatedAttestationsWrapper,
    [base_1.CeloContract.FeeCurrencyDirectory]: FeeCurrencyDirectoryWrapper_1.FeeCurrencyDirectoryWrapper,
    [base_1.CeloContract.FeeCurrencyWhitelist]: FeeCurrencyWhitelistWrapper_1.FeeCurrencyWhitelistWrapper,
    [base_1.CeloContract.Freezer]: Freezer_1.FreezerWrapper,
    [base_1.CeloContract.GasPriceMinimum]: GasPriceMinimum_1.GasPriceMinimumWrapper,
    [base_1.CeloContract.GoldToken]: GoldTokenWrapper_1.GoldTokenWrapper,
    // [CeloContract.Random]: RandomWrapper,
    // [CeloContract.Registry]: RegistryWrapper,
    [base_1.CeloContract.MultiSig]: MultiSig_1.MultiSigWrapper,
    [base_1.CeloContract.OdisPayments]: OdisPayments_1.OdisPaymentsWrapper,
    [base_1.CeloContract.Reserve]: Reserve_1.ReserveWrapper,
    [base_1.CeloContract.StableToken]: StableTokenWrapper_1.StableTokenWrapper,
    [base_1.CeloContract.StableTokenEUR]: StableTokenWrapper_1.StableTokenWrapper,
    [base_1.CeloContract.StableTokenBRL]: StableTokenWrapper_1.StableTokenWrapper,
};
const WithRegistry = {
    [base_1.CeloContract.SortedOracles]: SortedOracles_1.SortedOraclesWrapper,
};
const WrapperFactoriesWhichNeedCache = {
    [base_1.CeloContract.Attestations]: Attestations_1.AttestationsWrapper,
    [base_1.CeloContract.DoubleSigningSlasher]: DoubleSigningSlasher_1.DoubleSigningSlasherWrapper,
    [base_1.CeloContract.DowntimeSlasher]: DowntimeSlasher_1.DowntimeSlasherWrapper,
    [base_1.CeloContract.Election]: Election_1.ElectionWrapper,
    [base_1.CeloContract.Governance]: Governance_1.GovernanceWrapper,
    [base_1.CeloContract.LockedGold]: LockedGold_1.LockedGoldWrapper,
    [base_1.CeloContract.Validators]: Validators_1.ValidatorsWrapper,
};
const contractsWhichRequireCache = new Set(Object.keys(WrapperFactoriesWhichNeedCache));
/**
 * Kit ContractWrappers factory & cache.
 *
 * Provides access to all contract wrappers for celo core contracts
 *
 * @remarks
 *
 * Because it provides access to all contract wrappers it must load all wrappers and the contract ABIs for them
 * Consider Using {@link MiniWrapperCache}, building your own, or if you only need one Wrapper using it directly
 */
class WrapperCache {
    constructor(connection, _web3Contracts, registry) {
        this.connection = connection;
        this._web3Contracts = _web3Contracts;
        this.registry = registry;
        this.wrapperCache = {};
    }
    getAccounts() {
        return this.getContract(base_1.CeloContract.Accounts);
    }
    getAttestations() {
        return this.getContract(base_1.CeloContract.Attestations);
    }
    getBlockchainParameters() {
        return this.getContract(base_1.CeloContract.BlockchainParameters);
    }
    getCeloDistributionSchedule() {
        return this.getContract(base_1.CeloContract.CeloDistributionSchedule);
    }
    getDoubleSigningSlasher() {
        return this.getContract(base_1.CeloContract.DoubleSigningSlasher);
    }
    getDowntimeSlasher() {
        return this.getContract(base_1.CeloContract.DowntimeSlasher);
    }
    getElection() {
        return this.getContract(base_1.CeloContract.Election);
    }
    getEpochRewards() {
        return this.getContract(base_1.CeloContract.EpochRewards);
    }
    getErc20(address) {
        return this.getContract(base_1.CeloContract.ERC20, address);
    }
    getEscrow() {
        return this.getContract(base_1.CeloContract.Escrow);
    }
    getFreezer() {
        return this.getContract(base_1.CeloContract.Freezer);
    }
    getFederatedAttestations() {
        return this.getContract(base_1.CeloContract.FederatedAttestations);
    }
    getFeeCurrencyDirectory() {
        return this.getContract(base_1.CeloContract.FeeCurrencyDirectory);
    }
    getFeeCurrencyWhitelist() {
        return this.getContract(base_1.CeloContract.FeeCurrencyWhitelist);
    }
    getGasPriceMinimum() {
        return this.getContract(base_1.CeloContract.GasPriceMinimum);
    }
    getGoldToken() {
        return this.getContract(base_1.CeloContract.GoldToken);
    }
    getGovernance() {
        return this.getContract(base_1.CeloContract.Governance);
    }
    getLockedGold() {
        return this.getContract(base_1.CeloContract.LockedGold);
    }
    getMultiSig(address) {
        return this.getContract(base_1.CeloContract.MultiSig, address);
    }
    getOdisPayments() {
        return this.getContract(base_1.CeloContract.OdisPayments);
    }
    getReserve() {
        return this.getContract(base_1.CeloContract.Reserve);
    }
    getSortedOracles() {
        return this.getContract(base_1.CeloContract.SortedOracles);
    }
    getStableToken(stableToken = celo_tokens_1.StableToken.cUSD) {
        return this.getContract(celo_tokens_1.stableTokenInfos[stableToken].contract);
    }
    getValidators() {
        return this.getContract(base_1.CeloContract.Validators);
    }
    /**
     * Get Contract wrapper
     */
    getContract(contract, address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.wrapperCache[contract] == null || address !== undefined) {
                const instance = yield this._web3Contracts.getContract(contract, address);
                if (contract === base_1.CeloContract.SortedOracles) {
                    const Klass = WithRegistry[base_1.CeloContract.SortedOracles];
                    this.wrapperCache[base_1.CeloContract.SortedOracles] = new Klass(this.connection, instance, this.registry);
                }
                else if (contractsWhichRequireCache.has(contract)) {
                    const contractName = contract;
                    const Klass = WrapperFactoriesWhichNeedCache[contractName];
                    const wrapper = new Klass(this.connection, instance, this);
                    this.wrapperCache[contractName] = wrapper;
                }
                else {
                    const simpleContractName = contract;
                    const Klass = WrapperFactories[simpleContractName];
                    this.wrapperCache[simpleContractName] = new Klass(this.connection, instance);
                }
            }
            return this.wrapperCache[contract];
        });
    }
    invalidateContract(contract) {
        this._web3Contracts.invalidateContract(contract);
        this.wrapperCache[contract] = undefined;
    }
}
exports.WrapperCache = WrapperCache;
//# sourceMappingURL=contract-cache.js.map