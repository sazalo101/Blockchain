"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiSigWrapper = void 0;
const connect_1 = require("@celo/connect");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const BaseWrapper_1 = require("./BaseWrapper");
/**
 * Contract for handling multisig actions
 */
class MultiSigWrapper extends BaseWrapper_1.BaseWrapper {
    constructor() {
        super(...arguments);
        this.isOwner = (0, BaseWrapper_1.proxyCall)(this.contract.methods.isOwner);
        this.getOwners = (0, BaseWrapper_1.proxyCall)(this.contract.methods.getOwners);
        this.getRequired = (0, BaseWrapper_1.proxyCall)(this.contract.methods.required, undefined, BaseWrapper_1.valueToBigNumber);
        this.getInternalRequired = (0, BaseWrapper_1.proxyCall)(this.contract.methods.internalRequired, undefined, BaseWrapper_1.valueToBigNumber);
        this.totalTransactionCount = (0, BaseWrapper_1.proxyCall)(this.contract.methods.transactionCount, undefined, BaseWrapper_1.valueToInt);
        this.getTransactionCount = (0, BaseWrapper_1.proxyCall)(this.contract.methods.getTransactionCount, undefined, BaseWrapper_1.valueToInt);
        this.replaceOwner = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.replaceOwner, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.stringIdentity, BaseWrapper_1.stringIdentity));
    }
    /**
     * Allows an owner to submit and confirm a transaction.
     * If an unexecuted transaction matching `txObject` exists on the multisig, adds a confirmation to that tx ID.
     * Otherwise, submits the `txObject` to the multisig and add confirmation.
     * @param index The index of the pending withdrawal to withdraw.
     */
    submitOrConfirmTransaction(destination, txObject, value = '0') {
        return __awaiter(this, void 0, void 0, function* () {
            const data = (0, BaseWrapper_1.stringToSolidityBytes)(txObject.encodeABI());
            const transactionCount = yield this.contract.methods.getTransactionCount(true, true).call();
            let transactionId;
            for (transactionId = Number(transactionCount) - 1; transactionId >= 0; transactionId--) {
                const transaction = yield this.contract.methods.transactions(transactionId).call();
                if (transaction.data === data &&
                    transaction.destination === destination &&
                    transaction.value === value &&
                    !transaction.executed) {
                    return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.confirmTransaction(transactionId));
                }
            }
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.submitTransaction(destination, value, data));
        });
    }
    confirmTransaction(transactionId) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, connect_1.toTransactionObject)(this.connection, this.contract.methods.confirmTransaction(transactionId));
        });
    }
    getTransactionDataByContent(destination, txo, value = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = (0, BaseWrapper_1.stringToSolidityBytes)(txo.encodeABI());
            const transactionCount = yield this.getTransactionCount(true, true);
            const transactionsOrEmpties = yield Promise.all(Array(transactionCount)
                .fill(0)
                .map((_, index) => __awaiter(this, void 0, void 0, function* () {
                const tx = yield this.getTransaction(index, false);
                if (tx.data === data && tx.destination === destination && tx.value.isEqualTo(value)) {
                    return Object.assign({ index }, tx);
                }
                return null;
            })));
            const wantedTransaction = transactionsOrEmpties.find((tx) => tx !== null);
            if (!wantedTransaction) {
                return;
            }
            const confirmations = yield this.getConfirmations(wantedTransaction.index);
            return Object.assign(Object.assign({}, wantedTransaction), { confirmations });
        });
    }
    getTransaction(i, includeConfirmations = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const { destination, value, data, executed } = yield this.contract.methods
                .transactions(i)
                .call();
            if (!includeConfirmations) {
                return {
                    destination,
                    data,
                    executed,
                    value: new bignumber_js_1.default(value),
                };
            }
            const confirmations = yield this.getConfirmations(i);
            return {
                confirmations,
                destination,
                data,
                executed,
                value: new bignumber_js_1.default(value),
            };
        });
    }
    /*
     * Returns array of signer addresses which have confirmed a transaction
     * when given the index of that transaction.
     */
    getConfirmations(txId) {
        return __awaiter(this, void 0, void 0, function* () {
            const owners = yield this.getOwners();
            const confirmationsOrEmpties = yield Promise.all(owners.map((owner) => __awaiter(this, void 0, void 0, function* () {
                const confirmation = yield this.contract.methods.confirmations(txId, owner).call();
                if (confirmation) {
                    return owner;
                }
                else {
                    return null;
                }
            })));
            const confirmations = confirmationsOrEmpties.filter((c) => c !== null);
            return confirmations;
        });
    }
    getTransactions() {
        return __awaiter(this, void 0, void 0, function* () {
            const txcount = yield this.totalTransactionCount();
            const res = [];
            for (let i = 0; i < txcount; i++) {
                res.push(yield this.getTransaction(i));
            }
            return res;
        });
    }
}
exports.MultiSigWrapper = MultiSigWrapper;
//# sourceMappingURL=MultiSig.js.map