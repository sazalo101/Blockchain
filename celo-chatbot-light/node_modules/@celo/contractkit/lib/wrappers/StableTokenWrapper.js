"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StableTokenWrapper = void 0;
const BaseWrapper_1 = require("./BaseWrapper");
const CeloTokenWrapper_1 = require("./CeloTokenWrapper");
/**
 * Stable token with variable supply
 */
class StableTokenWrapper extends CeloTokenWrapper_1.CeloTokenWrapper {
    constructor() {
        super(...arguments);
        /**
         * Returns the address of the owner of the contract.
         * @return the address of the owner of the contract.
         */
        this.owner = (0, BaseWrapper_1.proxyCall)(this.contract.methods.owner);
        /**
         * Increases the allowance of another user.
         * @param spender The address which is being approved to spend StableToken.
         * @param value The increment of the amount of StableToken approved to the spender.
         * @returns true if success.
         */
        this.increaseAllowance = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.increaseAllowance, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.stringIdentity, BaseWrapper_1.valueToString));
        /**
         * Decreases the allowance of another user.
         * @param spender The address which is being approved to spend StableToken.
         * @param value The decrement of the amount of StableToken approved to the spender.
         * @returns true if success.
         */
        this.decreaseAllowance = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.decreaseAllowance);
        this.mint = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.mint);
        this.burn = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.burn);
    }
    /**
     * Returns current configuration parameters.
     */
    getConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield Promise.all([this.name(), this.symbol(), this.decimals()]);
            return {
                name: res[0],
                symbol: res[1],
                decimals: res[2],
            };
        });
    }
    /**
     * @dev Returns human readable configuration of the stabletoken contract
     * @return StableTokenConfig object
     */
    getHumanReadableConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield this.getConfig();
            return config;
        });
    }
}
exports.StableTokenWrapper = StableTokenWrapper;
//# sourceMappingURL=StableTokenWrapper.js.map