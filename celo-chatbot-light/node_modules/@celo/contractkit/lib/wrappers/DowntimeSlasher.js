"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DowntimeSlasherWrapper = void 0;
const BaseSlasher_1 = require("./BaseSlasher");
const BaseWrapper_1 = require("./BaseWrapper");
const unpackInterval = (interval) => [interval.start, interval.end];
/**
 * Contract handling slashing for Validator downtime using intervals.
 */
class DowntimeSlasherWrapper extends BaseSlasher_1.BaseSlasher {
    constructor() {
        super(...arguments);
        /**
         * Returns slashable downtime in blocks.
         * @return The number of consecutive blocks before a Validator missing from IBFT consensus
         * can be slashed.
         */
        this.slashableDowntime = (0, BaseWrapper_1.proxyCall)(this.contract.methods.slashableDowntime, undefined, BaseWrapper_1.valueToInt);
        /**
         * Calculates and returns the signature bitmap for the specified interval.
         * Similar to the parentSealBitmap of every block (where you have which validators were
         * able to sign the previous block), this bitmap shows for that specific interval which
         * validators signed at least one block
         * @param interval First and last block of the interval.
         * @return (string) The signature uptime bitmap for the specified interval.
         * @dev startBlock and endBlock must be in the same epoch.
         * @dev The getParentSealBitmap precompile requires that startBlock must be within 4 epochs of
         * the current block.
         */
        this.getBitmapForInterval = (0, BaseWrapper_1.proxyCall)(this.contract.methods.getBitmapForInterval, unpackInterval, BaseWrapper_1.solidityBytesToString);
        /**
         * Calculates and sets the signature bitmap for the specified interval.
         * @param interval First and last block of the interval.
         * @dev interval.start and interval.end must be in the same epoch.
         * @return The signature bitmap for the specified interval.
         */
        this.setBitmapForInterval = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.setBitmapForInterval, unpackInterval);
        /**
         * Shows if the user already called the `setBitmapForInterval` for
         * the specific interval.
         * @param interval First and last block of the interval.
         * @return True if the user already called the `setBitmapForInterval` for
         * the specific interval.
         */
        this.isBitmapSetForInterval = (0, BaseWrapper_1.proxyCall)(this.contract.methods.isBitmapSetForInterval, unpackInterval);
        this.lastSlashedBlock = (0, BaseWrapper_1.proxyCall)(this.contract.methods.lastSlashedBlock, undefined, BaseWrapper_1.valueToInt);
    }
    /**
     * Returns current configuration parameters.
     */
    getConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield Promise.all([this.slashableDowntime(), this.slashingIncentives()]);
            return {
                slashableDowntime: res[0],
                slashingIncentives: res[1],
            };
        });
    }
    /**
     * @dev Returns human readable configuration of the downtime slasher contract
     * @return DowntimeSlasherConfig object
     */
    getHumanReadableConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield this.getConfig();
            return Object.assign(Object.assign({}, config), { slashableDowntime: (0, BaseWrapper_1.blocksToDurationString)(config.slashableDowntime) });
        });
    }
    /**
     * Calculates intervals which span `slashableDowntime` before provided block.
     * @param block Block number to build intervals before.
     * @param maximumLength Maximum length for any interval (limited by gas limit).
     * @dev if block is undefined, latest will be used
     * @return The signature bitmap for the specified interval.
     */
    slashableDowntimeIntervalsBefore(block, maximumLength = 4000) {
        return __awaiter(this, void 0, void 0, function* () {
            const [window, blockchainParamsWrapper] = yield Promise.all([
                this.getSlashableDowntimeWindow(undefined, block),
                this.contracts.getBlockchainParameters(),
            ]);
            let end = window.end;
            const intervals = [];
            while (end > window.start) {
                const epochNumber = yield blockchainParamsWrapper.getEpochNumberOfBlock(end);
                const firstBlock = yield blockchainParamsWrapper.getFirstBlockNumberForEpoch(epochNumber);
                const start = Math.max(window.start, end - maximumLength, firstBlock);
                intervals.push({ start, end });
                end = start - 1;
            }
            return intervals.reverse();
        });
    }
    /**
     * Shows if the user already called the `setBitmapForInterval` for intervals.
     * @param intervals First and last block of the interval.
     * @return True if the user already called the `setBitmapForInterval` for intervals.
     */
    isBitmapSetForIntervals(intervals) {
        return __awaiter(this, void 0, void 0, function* () {
            const setArray = yield Promise.all(intervals.map((interval) => this.isBitmapSetForInterval(interval)));
            return !setArray.some((set) => !set);
        });
    }
    /**
     * Tests if the given validator or signer did not sign any blocks in the interval.
     * @param address Address of the validator account or signer.
     * @param interval First and last block of the interval.
     */
    wasValidatorDownForInterval(address, interval) {
        return __awaiter(this, void 0, void 0, function* () {
            const startSignerIndex = yield this.signerIndexAtBlock(address, interval.start);
            return this.contract.methods
                .wasDownForInterval(interval.start, interval.end, startSignerIndex)
                .call();
        });
    }
    /**
     * Returns true if the validator did not sign any blocks for the specified overlapping or adjacent
     * intervals.
     * @param address Address of the validator account or signer.
     * @param intervals
     * @return True if the validator signature does not appear in any block within the window.
     */
    wasValidatorDownForIntervals(address, intervals) {
        return __awaiter(this, void 0, void 0, function* () {
            const downArray = yield Promise.all(intervals.map((interval) => this.wasValidatorDownForInterval(address, interval)));
            return downArray.every((down) => down);
        });
    }
    /**
     * Returns true if the validator did not sign any blocks for the specified overlapping or adjacent
     * intervals.
     * @param address Address of the validator account or signer.
     * @param intervals A list of ordered intervals for which signature bitmaps have already been set.
     */
    slashValidator(address, intervals) {
        return __awaiter(this, void 0, void 0, function* () {
            if (intervals.length === 0) {
                throw new Error('intervals array should have at least one element');
            }
            const blockchainParamsWrapper = yield this.contracts.getBlockchainParameters();
            const signerIndices = [];
            let prevEpochNumber = -1;
            for (const interval of intervals) {
                const epochNumber = yield blockchainParamsWrapper.getFirstBlockNumberForEpoch(interval.start);
                if (epochNumber !== prevEpochNumber) {
                    const signerIndex = yield this.signerIndexAtBlock(address, interval.start);
                    signerIndices.push(signerIndex);
                    prevEpochNumber = epochNumber;
                }
            }
            return this.slash(intervals.map((interval) => interval.start), intervals.map((interval) => interval.end), signerIndices, ...(yield this.trailingSlashArgs(address, intervals[0].start)));
        });
    }
    /**
     * Calculate the slashable downtime window with respect to a provided start/end block numbers and length.
     * @param startBlock First block of the downtime. Determined from endBlock if not provided.
     * @param endBlock Last block of the downtime. Determined from startBlock or grandparent of latest block if not provided.
     * @param length Length of downtime. Determined from minimum slashable downtime if not provided.
     */
    getSlashableDowntimeWindow(startBlock, endBlock, length) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!length) {
                length = yield this.slashableDowntime();
            }
            if (!endBlock) {
                endBlock = startBlock ? startBlock + length - 1 : (yield this.connection.getBlockNumber()) - 2; // latest grandparent
            }
            return {
                start: startBlock !== null && startBlock !== void 0 ? startBlock : endBlock - length + 1,
                end: endBlock,
            };
        });
    }
}
exports.DowntimeSlasherWrapper = DowntimeSlasherWrapper;
//# sourceMappingURL=DowntimeSlasher.js.map