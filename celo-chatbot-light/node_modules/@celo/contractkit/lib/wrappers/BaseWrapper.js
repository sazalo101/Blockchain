"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.proxySend = exports.proxyCall = exports.tupleParser = exports.stringIdentity = exports.identity = exports.solidityBytesToString = exports.bufferToSolidityBytes = exports.stringToSolidityBytes = exports.unixSecondsTimestampToDateString = exports.blocksToDurationString = exports.secondsToDurationString = exports.valueToFrac = exports.valueToInt = exports.valueToFixidityString = exports.valueToString = exports.fixidityValueToBigNumber = exports.valueToBigNumber = exports.BaseWrapper = void 0;
const address_1 = require("@celo/base/lib/address");
const collections_1 = require("@celo/base/lib/collections");
const connect_1 = require("@celo/connect");
const fixidity_1 = require("@celo/utils/lib/fixidity");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const versions_1 = require("../versions");
/**
 * @internal -- use its children
 */
class BaseWrapper {
    constructor(connection, contract) {
        this.connection = connection;
        this.contract = contract;
        this.events = this.contract.events;
        this.eventTypes = Object.keys(this.events).reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: key })), {});
        this.methodIds = Object.keys(this.contract.methods).reduce((acc, method) => {
            const methodABI = this.contract.options.jsonInterface.find((item) => item.name === method);
            acc[method] =
                methodABI === undefined
                    ? '0x'
                    : this.connection.getAbiCoder().encodeFunctionSignature(methodABI);
            return acc;
        }, {});
    }
    /** Contract address */
    get address() {
        return this.contract.options.address;
    }
    version() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._version) {
                const raw = yield this.contract.methods.getVersionNumber().call();
                // @ts-ignore conditional type
                this._version = versions_1.ContractVersion.fromRaw(raw);
            }
            return this._version;
        });
    }
    onlyVersionOrGreater(version) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.version()).isAtLeast(version)) {
                throw new Error(`Bytecode version ${this._version} is not compatible with ${version} yet`);
            }
        });
    }
    /** Contract getPastEvents */
    getPastEvents(event, options) {
        return this.contract.getPastEvents(event, options);
    }
}
exports.BaseWrapper = BaseWrapper;
const valueToBigNumber = (input) => new bignumber_js_1.default(input);
exports.valueToBigNumber = valueToBigNumber;
const fixidityValueToBigNumber = (input) => (0, fixidity_1.fromFixed)(new bignumber_js_1.default(input));
exports.fixidityValueToBigNumber = fixidityValueToBigNumber;
const valueToString = (input) => (0, exports.valueToBigNumber)(input).toFixed();
exports.valueToString = valueToString;
const valueToFixidityString = (input) => (0, fixidity_1.toFixed)((0, exports.valueToBigNumber)(input)).toFixed();
exports.valueToFixidityString = valueToFixidityString;
const valueToInt = (input) => (0, exports.valueToBigNumber)(input).integerValue().toNumber();
exports.valueToInt = valueToInt;
const valueToFrac = (numerator, denominator) => (0, exports.valueToBigNumber)(numerator).div((0, exports.valueToBigNumber)(denominator));
exports.valueToFrac = valueToFrac;
var TimeDurations;
(function (TimeDurations) {
    TimeDurations[TimeDurations["millennium"] = 31536000000000] = "millennium";
    TimeDurations[TimeDurations["century"] = 3153600000000] = "century";
    TimeDurations[TimeDurations["decade"] = 315360000000] = "decade";
    TimeDurations[TimeDurations["year"] = 31536000000] = "year";
    TimeDurations[TimeDurations["quarter"] = 7776000000] = "quarter";
    TimeDurations[TimeDurations["month"] = 2592000000] = "month";
    TimeDurations[TimeDurations["week"] = 604800000] = "week";
    TimeDurations[TimeDurations["day"] = 86400000] = "day";
    TimeDurations[TimeDurations["hour"] = 3600000] = "hour";
    TimeDurations[TimeDurations["minute"] = 60000] = "minute";
    TimeDurations[TimeDurations["second"] = 1000] = "second";
    TimeDurations[TimeDurations["millisecond"] = 1] = "millisecond";
})(TimeDurations || (TimeDurations = {}));
// taken mostly from https://gist.github.com/RienNeVaPlus/024de3431ae95546d60f2acce128a7e2
function secondsToDurationString(durationSeconds, outputUnits = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second']) {
    let durationMilliseconds = (0, exports.valueToBigNumber)(durationSeconds)
        .times(TimeDurations.second)
        .toNumber();
    if (durationMilliseconds <= 0) {
        return 'past';
    }
    const durations = outputUnits.reduce((res, key) => {
        const unitDuration = TimeDurations[key];
        const value = Math.floor(durationMilliseconds / unitDuration);
        durationMilliseconds -= value * unitDuration;
        return res.set(key, value);
    }, new Map());
    let s = '';
    durations.forEach((value, unit) => {
        if (value > 0) {
            s += s !== '' ? ', ' : '';
            s += `${value} ${unit}${value > 1 ? 's' : ''}`;
        }
    });
    return s;
}
exports.secondsToDurationString = secondsToDurationString;
const blocksToDurationString = (input) => secondsToDurationString((0, exports.valueToBigNumber)(input).times(5)); // TODO: fetch blocktime
exports.blocksToDurationString = blocksToDurationString;
const DATE_TIME_OPTIONS = {
    year: 'numeric',
    month: 'short',
    weekday: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: 'numeric',
    timeZoneName: 'short',
};
const unixSecondsTimestampToDateString = (input) => {
    const date = new Date((0, exports.valueToInt)(input) * TimeDurations.second);
    return Intl.DateTimeFormat('default', DATE_TIME_OPTIONS).format(date);
};
exports.unixSecondsTimestampToDateString = unixSecondsTimestampToDateString;
const stringToSolidityBytes = (input) => (0, address_1.ensureLeading0x)(input);
exports.stringToSolidityBytes = stringToSolidityBytes;
const bufferToSolidityBytes = (input) => (0, exports.stringToSolidityBytes)((0, address_1.bufferToHex)(input));
exports.bufferToSolidityBytes = bufferToSolidityBytes;
const solidityBytesToString = (input) => {
    if (input === null || input === undefined || typeof input === 'string') {
        return input;
    }
    else if (Array.isArray(input)) {
        const hexString = input.reduce((acc, num) => acc + num.toString(16).padStart(2, '0'), '');
        return (0, address_1.ensureLeading0x)(hexString);
    }
    else {
        throw new Error('Unexpected input type for solidity bytes');
    }
};
exports.solidityBytesToString = solidityBytesToString;
/** Identity Parser */
const identity = (a) => a;
exports.identity = identity;
const stringIdentity = (x) => x;
exports.stringIdentity = stringIdentity;
function tupleParser(...parsers) {
    return (...args) => (0, collections_1.zip)((parser, input) => parser(input), parsers, args);
}
exports.tupleParser = tupleParser;
function proxyCall(...callArgs) {
    if (callArgs.length === 3 && callArgs[1] != null) {
        const methodFn = callArgs[0];
        const parseInputArgs = callArgs[1];
        const parseOutput = callArgs[2];
        return (...args) => methodFn(...parseInputArgs(...args))
            .call()
            .then(parseOutput);
    }
    else if (callArgs.length === 3) {
        const methodFn = callArgs[0];
        const parseOutput = callArgs[2];
        return (...args) => methodFn(...args)
            .call()
            .then(parseOutput);
    }
    else if (callArgs.length === 2) {
        const methodFn = callArgs[0];
        const parseInputArgs = callArgs[1];
        return (...args) => methodFn(...parseInputArgs(...args)).call();
    }
    else {
        const methodFn = callArgs[0];
        return (...args) => methodFn(...args).call();
    }
}
exports.proxyCall = proxyCall;
/**
 * Creates a proxy to send a tx on a web3 native contract method.
 *
 * There are 2 cases:
 *  - call methodFn (no pre or post parsing)
 *  - preParse arguments & call methodFn
 *
 * @param methodFn Web3 methods function
 * @param preParse [optional] preParse function, tranforms arguments into `methodFn` expected inputs
 */
function proxySend(connection, ...sendArgs) {
    if (sendArgs.length === 2) {
        const methodFn = sendArgs[0];
        const preParse = sendArgs[1];
        return (...args) => (0, connect_1.toTransactionObject)(connection, methodFn(...preParse(...args)));
    }
    else {
        const methodFn = sendArgs[0];
        return (...args) => (0, connect_1.toTransactionObject)(connection, methodFn(...args));
    }
}
exports.proxySend = proxySend;
//# sourceMappingURL=BaseWrapper.js.map