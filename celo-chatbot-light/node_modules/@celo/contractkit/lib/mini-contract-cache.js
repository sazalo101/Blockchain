"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MiniContractCache = void 0;
const GasPriceMinimum_1 = require("@celo/abis/web3/0.8/GasPriceMinimum");
const Accounts_1 = require("@celo/abis/web3/Accounts");
const GoldToken_1 = require("@celo/abis/web3/GoldToken");
const StableToken_1 = require("@celo/abis/web3/mento/StableToken");
const StableTokenBRL_1 = require("@celo/abis/web3/mento/StableTokenBRL");
const StableTokenEUR_1 = require("@celo/abis/web3/mento/StableTokenEUR");
const base_1 = require("@celo/base");
const base_2 = require("./base");
const celo_tokens_1 = require("./celo-tokens");
const Accounts_2 = require("./wrappers/Accounts");
const GasPriceMinimum_2 = require("./wrappers/GasPriceMinimum");
const GoldTokenWrapper_1 = require("./wrappers/GoldTokenWrapper");
const StableTokenWrapper_1 = require("./wrappers/StableTokenWrapper");
const MINIMUM_CONTRACTS = {
    [base_2.CeloContract.Accounts]: {
        newInstance: Accounts_1.newAccounts,
        wrapper: Accounts_2.AccountsWrapper,
    },
    [base_2.CeloContract.GasPriceMinimum]: {
        newInstance: GasPriceMinimum_1.newGasPriceMinimum,
        wrapper: GasPriceMinimum_2.GasPriceMinimumWrapper,
    },
    [base_2.CeloContract.GoldToken]: {
        newInstance: GoldToken_1.newGoldToken,
        wrapper: GoldTokenWrapper_1.GoldTokenWrapper,
    },
    [base_2.CeloContract.StableToken]: {
        newInstance: StableToken_1.newStableToken,
        wrapper: StableTokenWrapper_1.StableTokenWrapper,
    },
    [base_2.CeloContract.StableTokenBRL]: {
        newInstance: StableTokenBRL_1.newStableTokenBRL,
        wrapper: StableTokenWrapper_1.StableTokenWrapper,
    },
    [base_2.CeloContract.StableTokenEUR]: {
        newInstance: StableTokenEUR_1.newStableTokenEUR,
        wrapper: StableTokenWrapper_1.StableTokenWrapper,
    },
};
const contractsWhichRequireCache = new Set([
    base_2.CeloContract.Attestations,
    base_2.CeloContract.DoubleSigningSlasher,
    base_2.CeloContract.DowntimeSlasher,
    base_2.CeloContract.Election,
    base_2.CeloContract.Governance,
    base_2.CeloContract.LockedGold,
    base_2.CeloContract.Validators,
]);
/**
 * Alternative Contract Cache with Minimal Contracts
 *
 * Provides access to a subset of wrappers: {@link AccountsWrapper}, {@link GasPriceMinimumWrapper} and Celo Token contracts
 * Used internally by {@link MiniContractKit}
 *
 * @param connection – {@link Connection}
 * @param registry – {@link AddressRegistry}
 */
class MiniContractCache {
    constructor(connection, registry, contractClasses = MINIMUM_CONTRACTS) {
        this.connection = connection;
        this.registry = registry;
        this.contractClasses = contractClasses;
        this.cache = new Map();
    }
    getAccounts() {
        return this.getContract(base_2.CeloContract.Accounts);
    }
    getGoldToken() {
        return this.getContract(base_2.CeloContract.GoldToken);
    }
    getStableToken(stableToken = base_1.StableToken.cUSD) {
        return this.getContract(celo_tokens_1.stableTokenInfos[stableToken].contract);
    }
    /**
     * Get Contract wrapper
     */
    getContract(contract, address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isContractAvailable(contract)) {
                throw new Error(`This instance of MiniContracts was not given a mapping for ${contract}. Either add it or use WrapperCache for full set of contracts`);
            }
            if (contractsWhichRequireCache.has(contract)) {
                throw new Error(`${contract} cannot be used with MiniContracts as it requires an instance of WrapperCache to be passed in as an argument`);
            }
            if (this.cache.get(contract) == null || address !== undefined) {
                yield this.setContract(contract, address);
            }
            return this.cache.get(contract);
        });
    }
    setContract(contract, address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!address) {
                address = yield this.registry.addressFor(contract);
            }
            const classes = this.contractClasses[contract];
            const instance = classes.newInstance(this.connection.web3, address);
            const Klass = classes.wrapper;
            const wrapper = new Klass(this.connection, instance);
            this.cache.set(contract, wrapper);
        });
    }
    invalidateContract(contract) {
        this.cache.delete(contract);
    }
    isContractAvailable(contract) {
        return !!this.contractClasses[contract];
    }
}
exports.MiniContractCache = MiniContractCache;
//# sourceMappingURL=mini-contract-cache.js.map