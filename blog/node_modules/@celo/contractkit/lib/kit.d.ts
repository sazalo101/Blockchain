import { StrongAddress } from '@celo/base';
import { CeloTx, CeloTxObject, Connection, ReadOnlyWallet, TransactionResult } from '@celo/connect';
import { EIP712TypedData } from '@celo/utils/lib/sign-typed-data-utils';
import { Signature } from '@celo/utils/lib/signatureUtils';
import { BigNumber } from 'bignumber.js';
import Web3 from 'web3';
import { AddressRegistry } from './address-registry';
import { CeloContract } from './base';
import { CeloTokens, EachCeloToken } from './celo-tokens';
import { WrapperCache } from './contract-cache';
import { HttpProviderOptions } from './setupForKits';
import { Web3ContractCache } from './web3-contract-cache';
import { AttestationsConfig } from './wrappers/Attestations';
import { BlockchainParametersConfig } from './wrappers/BlockchainParameters';
import { DowntimeSlasherConfig } from './wrappers/DowntimeSlasher';
import { ElectionConfig } from './wrappers/Election';
import { GasPriceMinimumConfig } from './wrappers/GasPriceMinimum';
import { GovernanceConfig } from './wrappers/Governance';
import { LockedGoldConfig } from './wrappers/LockedGold';
import { ReserveConfig } from './wrappers/Reserve';
import { SortedOraclesConfig } from './wrappers/SortedOracles';
import { StableTokenConfig } from './wrappers/StableTokenWrapper';
import { ValidatorsConfig } from './wrappers/Validators';
export { API_KEY_HEADER_KEY, HttpProviderOptions } from './setupForKits';
/**
 * Creates a new instance of `ContractKit` given a nodeUrl
 * @param url CeloBlockchain node url
 * @optional wallet to reuse or add a wallet different than the default (example ledger-wallet)
 * @optional options to pass to the Web3 HttpProvider constructor
 */
export declare function newKit(url: string, wallet?: ReadOnlyWallet, options?: HttpProviderOptions): ContractKit;
/**
 * Creates a new instance of `ContractKit` given a nodeUrl and apiKey
 * @param url CeloBlockchain node url
 * @param apiKey to include in the http request header
 * @optional wallet to reuse or add a wallet different than the default (example ledger-wallet)
 */
export declare function newKitWithApiKey(url: string, apiKey: string, wallet?: ReadOnlyWallet): ContractKit;
/**
 * Creates a new instance of the `ContractKit` with a web3 instance
 * @param web3 Web3 instance
 */
export declare function newKitFromWeb3(web3: Web3, wallet?: ReadOnlyWallet): ContractKit;
export interface NetworkConfig {
    stableTokens: EachCeloToken<StableTokenConfig>;
    election: ElectionConfig;
    attestations: AttestationsConfig;
    governance: GovernanceConfig;
    lockedGold: LockedGoldConfig;
    sortedOracles: SortedOraclesConfig;
    gasPriceMinimum: GasPriceMinimumConfig;
    reserve: ReserveConfig;
    validators: ValidatorsConfig;
    downtimeSlasher: DowntimeSlasherConfig;
    blockchainParameters: BlockchainParametersConfig;
}
interface AccountBalance extends EachCeloToken<BigNumber> {
    lockedCELO: BigNumber;
    pending: BigNumber;
}
export declare class ContractKit {
    readonly connection: Connection;
    /** core contract's address registry */
    readonly registry: AddressRegistry;
    /** factory for core contract's native web3 wrappers  */
    readonly _web3Contracts: Web3ContractCache;
    /** factory for core contract's kit wrappers  */
    readonly contracts: WrapperCache;
    /** helper for interacting with CELO & stable tokens */
    readonly celoTokens: CeloTokens;
    /** @deprecated no longer needed since gasPrice is available on node rpc */
    gasPriceSuggestionMultiplier: number;
    constructor(connection: Connection);
    getWallet(): ReadOnlyWallet | undefined;
    getTotalBalance(address: string): Promise<AccountBalance>;
    getNetworkConfig(humanReadable?: boolean): Promise<NetworkConfig | Record<CeloContract & 'stableTokens', unknown>>;
    getHumanReadableNetworkConfig: () => Promise<NetworkConfig | Record<never, unknown>>;
    /**
     * Set an addressed to use to pay for gas fees
     * @param address any hexadecimal address
     * @dev Throws if supplied address is not a valid hexadecimal address
     */
    setFeeCurrency(address: StrongAddress): void;
    getEpochSize(): Promise<number>;
    getFirstBlockNumberForEpoch(epochNumber: number): Promise<number>;
    getLastBlockNumberForEpoch(epochNumber: number): Promise<number>;
    getEpochNumberOfBlock(blockNumber: number): Promise<number>;
    populateMaxFeeInToken(tx: CeloTx & Pick<Required<CeloTx>, 'feeCurrency'>): Promise<CeloTx>;
    /**
     * For cip 66 transactions (the prefered way to pay for gas with fee tokens on Cel2) it is necessary
     * to provide the absolute limit one is willing to pay denominated in the token.
     * In contrast with earlier tx types for fee currencies (celo legacy, cip42, cip 64).
     *
     * Calulating Estimation requires the gas, maxfeePerGas and the conversion rate from CELO to feeToken
     * https://github.com/celo-org/celo-proposals/blob/master/CIPs/cip-0066.md
     */
    estimateMaxFeeInFeeToken({ gasLimit, maxFeePerGas, feeCurrency, }: {
        gasLimit: bigint;
        maxFeePerGas: bigint;
        feeCurrency: StrongAddress;
    }): Promise<bigint>;
    addAccount(privateKey: string): void;
    set defaultAccount(address: StrongAddress | undefined);
    get defaultAccount(): StrongAddress | undefined;
    set gasInflationFactor(factor: number);
    get gasInflationFactor(): number;
    set defaultFeeCurrency(address: StrongAddress | undefined);
    get defaultFeeCurrency(): StrongAddress | undefined;
    isListening(): Promise<boolean>;
    isSyncing(): Promise<boolean>;
    sendTransaction(tx: CeloTx): Promise<TransactionResult>;
    sendTransactionObject(txObj: CeloTxObject<any>, tx?: Omit<CeloTx, 'data'>): Promise<TransactionResult>;
    signTypedData(signer: string, typedData: EIP712TypedData): Promise<Signature>;
    stop(): void;
    get web3(): Web3;
}
