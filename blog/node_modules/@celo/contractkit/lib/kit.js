"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractKit = exports.newKitFromWeb3 = exports.newKitWithApiKey = exports.newKit = exports.API_KEY_HEADER_KEY = void 0;
const connect_1 = require("@celo/connect");
const wallet_local_1 = require("@celo/wallet-local");
const bignumber_js_1 = require("bignumber.js");
const address_registry_1 = require("./address-registry");
const base_1 = require("./base");
const celo_tokens_1 = require("./celo-tokens");
const contract_cache_1 = require("./contract-cache");
const setupForKits_1 = require("./setupForKits");
const web3_contract_cache_1 = require("./web3-contract-cache");
var setupForKits_2 = require("./setupForKits");
Object.defineProperty(exports, "API_KEY_HEADER_KEY", { enumerable: true, get: function () { return setupForKits_2.API_KEY_HEADER_KEY; } });
/**
 * Creates a new instance of `ContractKit` given a nodeUrl
 * @param url CeloBlockchain node url
 * @optional wallet to reuse or add a wallet different than the default (example ledger-wallet)
 * @optional options to pass to the Web3 HttpProvider constructor
 */
function newKit(url, wallet, options) {
    const web3 = (0, setupForKits_1.getWeb3ForKit)(url, options);
    return newKitFromWeb3(web3, wallet);
}
exports.newKit = newKit;
/**
 * Creates a new instance of `ContractKit` given a nodeUrl and apiKey
 * @param url CeloBlockchain node url
 * @param apiKey to include in the http request header
 * @optional wallet to reuse or add a wallet different than the default (example ledger-wallet)
 */
function newKitWithApiKey(url, apiKey, wallet) {
    const options = (0, setupForKits_1.setupAPIKey)(apiKey);
    return newKit(url, wallet, options);
}
exports.newKitWithApiKey = newKitWithApiKey;
/**
 * Creates a new instance of the `ContractKit` with a web3 instance
 * @param web3 Web3 instance
 */
function newKitFromWeb3(web3, wallet = new wallet_local_1.LocalWallet()) {
    (0, setupForKits_1.ensureCurrentProvider)(web3);
    return new ContractKit(new connect_1.Connection(web3, wallet));
}
exports.newKitFromWeb3 = newKitFromWeb3;
/*
 * ContractKit provides a convenient interface for All Celo Contracts
 *
 * @remarks
 *
 * For most use cases this ContractKit class might be more than you need.
 * Consider {@link MiniContractKit} for a scaled down subset of contract Wrappers,
 * or {@link Connection} for a lighter package without contract Wrappers
 *
 * @param connection â€“ an instance of @celo/connect {@link Connection}
 */
class ContractKit {
    constructor(connection) {
        this.connection = connection;
        /** @deprecated no longer needed since gasPrice is available on node rpc */
        this.gasPriceSuggestionMultiplier = 5;
        this.getHumanReadableNetworkConfig = () => this.getNetworkConfig(true);
        this.registry = new address_registry_1.AddressRegistry(connection);
        this._web3Contracts = new web3_contract_cache_1.Web3ContractCache(this.registry);
        this.contracts = new contract_cache_1.WrapperCache(connection, this._web3Contracts, this.registry);
        this.celoTokens = new celo_tokens_1.CeloTokens(this.contracts, this.registry);
    }
    getWallet() {
        return this.connection.wallet;
    }
    getTotalBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const lockedCelo = yield this.contracts.getLockedGold();
            const lockedBalance = yield lockedCelo.getAccountTotalLockedGold(address);
            let pending = new bignumber_js_1.BigNumber(0);
            try {
                pending = yield lockedCelo.getPendingWithdrawalsTotalValue(address);
            }
            catch (err) {
                // Just means that it's not an account
            }
            return Object.assign({ lockedCELO: lockedBalance, pending }, (yield this.celoTokens.balancesOf(address)));
        });
    }
    getNetworkConfig(humanReadable = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let configContracts;
            if (yield (0, connect_1.isCel2)(this.web3)) {
                configContracts = [
                    base_1.CeloContract.Election,
                    base_1.CeloContract.Governance,
                    base_1.CeloContract.LockedGold,
                    base_1.CeloContract.SortedOracles,
                    base_1.CeloContract.Reserve,
                    base_1.CeloContract.Validators,
                    base_1.CeloContract.DowntimeSlasher,
                    base_1.CeloContract.FeeCurrencyDirectory,
                    base_1.CeloContract.CeloDistributionSchedule,
                ];
            }
            else {
                configContracts = [
                    base_1.CeloContract.Election,
                    base_1.CeloContract.Attestations,
                    base_1.CeloContract.Governance,
                    base_1.CeloContract.LockedGold,
                    base_1.CeloContract.SortedOracles,
                    base_1.CeloContract.GasPriceMinimum,
                    base_1.CeloContract.Reserve,
                    base_1.CeloContract.Validators,
                    base_1.CeloContract.DowntimeSlasher,
                    base_1.CeloContract.BlockchainParameters,
                    base_1.CeloContract.EpochRewards,
                ];
            }
            const configMethod = (contract) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const eachTokenAddress = yield this.celoTokens.getAddresses();
                    const addresses = Object.values(eachTokenAddress);
                    const configContractWrapper = yield this.contracts.getContract(contract);
                    if (humanReadable && 'getHumanReadableConfig' in configContractWrapper) {
                        return configContractWrapper.getHumanReadableConfig(addresses);
                    }
                    else if ('getConfig' in configContractWrapper) {
                        return configContractWrapper.getConfig(addresses);
                    }
                    else {
                        throw new Error('No config endpoint found');
                    }
                }
                catch (e) {
                    return new Error(`Failed to fetch config for contract ${contract}: \n${e}`);
                }
            });
            const configArray = yield Promise.all(configContracts.map(configMethod));
            const configMap = {};
            configArray.forEach((config, index) => (configMap[configContracts[index]] = config));
            return Object.assign({}, configMap);
        });
    }
    /**
     * Set an addressed to use to pay for gas fees
     * @param address any hexadecimal address
     * @dev Throws if supplied address is not a valid hexadecimal address
     */
    setFeeCurrency(address) {
        if (!this.web3.utils.isAddress(address)) {
            throw new Error('Supplied address is not a valid hexadecimal address.');
        }
        this.connection.defaultFeeCurrency = address;
    }
    /*
     * @deprecated - epoch related methods will be removed from contractkit
     */
    getEpochSize() {
        return __awaiter(this, void 0, void 0, function* () {
            const blockchainParamsWrapper = yield this.contracts.getBlockchainParameters();
            return blockchainParamsWrapper.getEpochSizeNumber();
        });
    }
    /*
     * @deprecated - epoch related methods will be removed from contractkit
     */
    getFirstBlockNumberForEpoch(epochNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockchainParamsWrapper = yield this.contracts.getBlockchainParameters();
            return blockchainParamsWrapper.getFirstBlockNumberForEpoch(epochNumber);
        });
    }
    /*
     * @deprecated - epoch related methods will be removed from contractkit
     */
    getLastBlockNumberForEpoch(epochNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockchainParamsWrapper = yield this.contracts.getBlockchainParameters();
            return blockchainParamsWrapper.getLastBlockNumberForEpoch(epochNumber);
        });
    }
    /*
     * @deprecated - epoch related methods will be removed from contractkit
     */
    getEpochNumberOfBlock(blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockchainParamsWrapper = yield this.contracts.getBlockchainParameters();
            return blockchainParamsWrapper.getEpochNumberOfBlock(blockNumber);
        });
    }
    /*
     * Sets the maxFeeInFeeCurrency on the provided transaction
     *
     * @remarks
     * Because tx with maxFeeInFeeCurrency set require maxPriorityFeePerGas and maxFeePerGas to be expressed in CELO
     * and previous tx types with feeCurrency expressed these in the token paying for the transaction,
     * this method overwrites maxPriorityFeePerGas and maxFeePerGas to ensure they are correctly valued in CELO
     *
     * @dev This transaction type is not yet supported
     *
     * @param tx.gas is required
     */
    populateMaxFeeInToken(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield (0, connect_1.isCel2)(this.connection.web3))) {
                throw new Error("Can't populate `maxFeeInFeeCurrency` if not on a CEL2 network");
            }
            if ((0, connect_1.isPresent)(tx.feeCurrency) && !(0, connect_1.isPresent)(tx.maxFeeInFeeCurrency)) {
                if (!(0, connect_1.isPresent)(tx.gas)) {
                    tx.gas = yield this.connection.estimateGas(tx);
                }
                // Force maxFeePerGas and maxPriorityFeePerGas to be expressed in CELO
                const [maxFeePerGas, maxPriorityFeePerGas] = yield Promise.all([
                    this.connection.gasPrice(),
                    yield this.connection.rpcCaller.call('eth_maxPriorityFeePerGas', []).then((x) => x.result),
                ]);
                tx.maxFeePerGas = new bignumber_js_1.BigNumber(maxFeePerGas).toString(10);
                tx.maxPriorityFeePerGas = new bignumber_js_1.BigNumber(maxPriorityFeePerGas).toString(10);
                const maxFeeInFeeCurrency = yield this.estimateMaxFeeInFeeToken({
                    feeCurrency: tx.feeCurrency,
                    gasLimit: BigInt(tx.gas),
                    maxFeePerGas: BigInt(maxFeePerGas),
                });
                tx.maxFeeInFeeCurrency = maxFeeInFeeCurrency.toString(10);
            }
            return tx;
        });
    }
    /**
     * For cip 66 transactions (the prefered way to pay for gas with fee tokens on Cel2) it is necessary
     * to provide the absolute limit one is willing to pay denominated in the token.
     * In contrast with earlier tx types for fee currencies (celo legacy, cip42, cip 64).
     *
     * Calulating Estimation requires the gas, maxfeePerGas and the conversion rate from CELO to feeToken
     * https://github.com/celo-org/celo-proposals/blob/master/CIPs/cip-0066.md
     */
    estimateMaxFeeInFeeToken({ gasLimit, maxFeePerGas, feeCurrency, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const maxGasFeesInCELO = gasLimit * maxFeePerGas;
            const feeCurrencyDirectoryWrapper = yield this.contracts.getFeeCurrencyDirectory();
            const { numerator: ratioTOKEN, denominator: ratioCELO } = yield feeCurrencyDirectoryWrapper.getExchangeRate(feeCurrency);
            return (
            // convert from celo to token and add 2 percent wriggle room, 102/100 you cant pre calculate this as it will just be 1 then
            (((maxGasFeesInCELO * BigInt(ratioCELO.toString(10))) / BigInt(ratioTOKEN.toString(10))) *
                BigInt(102)) /
                BigInt(100));
        });
    }
    // *** NOTICE ***
    // Next functions exists for backwards compatibility
    // These should be consumed via connection to avoid future deprecation issues
    addAccount(privateKey) {
        this.connection.addAccount(privateKey);
    }
    set defaultAccount(address) {
        this.connection.defaultAccount = address;
    }
    get defaultAccount() {
        return this.connection.defaultAccount;
    }
    set gasInflationFactor(factor) {
        this.connection.defaultGasInflationFactor = factor;
    }
    get gasInflationFactor() {
        return this.connection.defaultGasInflationFactor;
    }
    set defaultFeeCurrency(address) {
        this.connection.defaultFeeCurrency = address;
    }
    get defaultFeeCurrency() {
        return this.connection.defaultFeeCurrency;
    }
    isListening() {
        return this.connection.isListening();
    }
    isSyncing() {
        return this.connection.isSyncing();
    }
    sendTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.sendTransaction(tx);
        });
    }
    sendTransactionObject(txObj, tx) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.sendTransactionObject(txObj, tx);
        });
    }
    signTypedData(signer, typedData) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.signTypedData(signer, typedData);
        });
    }
    stop() {
        this.connection.stop();
    }
    get web3() {
        return this.connection.web3;
    }
}
exports.ContractKit = ContractKit;
//# sourceMappingURL=kit.js.map