"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressRegistry = exports.UnregisteredError = exports.REGISTRY_CONTRACT_ADDRESS = void 0;
/* eslint max-classes-per-file:off */
const Registry_1 = require("@celo/abis/web3/Registry");
const address_1 = require("@celo/base/lib/address");
const debug_1 = __importDefault(require("debug"));
const base_1 = require("./base");
const debug = (0, debug_1.default)('kit:registry');
// Registry contract is always predeployed to this address
exports.REGISTRY_CONTRACT_ADDRESS = '0x000000000000000000000000000000000000ce10';
class UnregisteredError extends Error {
    constructor(contract) {
        super(`${contract} not (yet) registered`);
    }
}
exports.UnregisteredError = UnregisteredError;
/**
 * Celo Core Contract's Address Registry
 *
 * @param connection â€“ an instance of @celo/connect {@link Connection}
 */
class AddressRegistry {
    constructor(connection) {
        this.connection = connection;
        this.cache = new Map();
        this.cache.set(base_1.CeloContract.Registry, exports.REGISTRY_CONTRACT_ADDRESS);
        this.registry = (0, Registry_1.newRegistry)(connection.web3, exports.REGISTRY_CONTRACT_ADDRESS);
    }
    /**
     * Get the address for a `CeloContract`
     */
    addressFor(contract) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cache.has(contract)) {
                debug('Fetching address from Registry for %s', contract);
                const address = yield this.registry.methods.getAddressForString((0, base_1.stripProxy)(contract)).call();
                debug('Fetched address %s', address);
                if (!address || address === address_1.NULL_ADDRESS) {
                    throw new UnregisteredError(contract);
                }
                this.cache.set(contract, address);
            }
            const cachedAddress = this.cache.get(contract);
            return cachedAddress;
        });
    }
    /**
     * Get the address mapping for known registered contracts
     */
    addressMapping() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(base_1.RegisteredContracts.map((contract) => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this.addressFor(contract);
                }
                catch (e) {
                    debug(e);
                }
            })));
            return this.cache;
        });
    }
}
exports.AddressRegistry = AddressRegistry;
//# sourceMappingURL=address-registry.js.map